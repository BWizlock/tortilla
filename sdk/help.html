<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf8">
<meta http-equiv="content-language" content="ru">
<title>Tortilla мад клиент</title>
<style type="text/css">
body{ background-color: #202020; color: #ffffff; font-size: 16px; font-family: consolas, tahoma; }
h1 { font-size: 40px; color: RGB(210,121,32); align: center; }
h2 { font-size: 28px; color: #1e9da8; }
h3 { font-size: 18px; color: #1e9da8; margin-bottom: 4px; }
h4 { font-size: 18px; color: yellow; margin-bottom: 2px; }
.t { color: #20c020; display: inline; }
.m { color: #20c020; display: inline; }
.e { color: #2080c0; display: inline; }
.ee { color: #909090; border-width: 1px; border-style: solid; width: 40% }
.cmd { color: yellow; display: inline; }
.leftimg { float:left; margin: 7px 7px 7px 0; }
.rightimg  { float: right; margin: 7px 0 7px 7px; }
a.content { color: #20c020; }
hr { border: 1px dashed; color: #909090; }
</style>
</head>
<body link="#3366cc" alink="#ff0000" vlink="#3366cc">
<a name="top"></a>
<center><h1>Tortilla SDK<br></h1></center>

<h2>Содержание</h2>
<ul>
<li><a href="#description">Описание, состав SDK</a></li>
<li><a href="#modules">Модули</a></li>
<li><a href="#plugins">Плагины</a></li>
<li><a href="#devcpp">Разработка на С,С++</a></li>
<li><a href="#devlua">Разработка на Lua</a></li>
<li><a href="#pluginsapi">Функции взаимодействия клиента с плагином, API плагина</a></li>
<li><a href="#clientapi">Функции взаимодействия плагина с клиентом, API клиента</a></li>
<li><a href="#strings">Cтроки, ньюансы работы в Lua</a></li>
<li><a href="#decoda">Decoda</a></li>
</ul>

<h2>Введение</h2>
Tortilla - это клиент для игры в текстовые многопользовательские онлайновые игры MUD (multi users dangeons, dimension or domains games).<br>
Предварительно следует ознакомиться с самой программой на <a href="https://github.com/tmud/tortilla" target="_blank">Сайте программы</a>. Данная информация предназначена для разработчиков под данный клиент.<br><br>
Разработка с помощью SDK предполагает испльзование языков программирования: <div class="m">C</div>, <div class="m">C++</div>, <div class="m">Lua 5.2</div>.<br><br>
Если вы не знаете <div class="m">Lua</div>, то его можно быстро выучить, благодаря этой статье <a href="http://tylerneylon.com/a/learn-lua/" target="_blank">Lua за 15 минут</a>. В данной 
статье собраны все основные правила данного языка, без лишней информации. Этих знаний будет вполне достаточно, чтобы научиться писать плагины и модули для клиента. Если будет желание 
изучить язык <div class="m">Lua</div> получше, то очень советую книгу <div class="m">Programming in Lua, 3rd Edition, Roberto Ierusalimschy</div>.
Дополнительно много информации и статей по данному языку, не считая официальную документацию <a href="http://lua.org" target="_blank">http://lua.org</a>, можно найти в интернете. 
Следует обратить внимание, что в клиенте используется <div class="m">Lua 5.2</div>.

<a name="description"></a>
<h2>Описание, состав SDK</h2>
Данный пакет SDK с набором компонентов предназначен для разработки плагинов и модулей для мад-клиента Tortilla.<br>
Он состоит из:
<ul>
<li><div class="m">Справки</div></li>
<li><div class="m">Библиотек и заголовочных файлов для компиляции</div></li>
<li><div class="m">Проектов-шаблонов, готовых для реализации в них нужного функционала</div></li>
<li><div class="m">Среды разработки для языка Lua - Decoda</div></li>
</ul>
Библиотеки и заголовочные файлы, а также проекты-шаблоны используются для разработки на языке С++. Они расчитаны на использование в <div class="m">Visual Studio 2013</div>.<br>
Если вы будете создавать в плагинах интерфейсные окна, то тогда <div class="m">Express</div> версия <div class="m">Visual Studio</div> скорее всего 
не подойдет, придется использовать <div class="m">Visual Studio 2013 Professional</div> и выше.<br>
Вполне возможна разработка плагинов и модулей на <div class="m">Delphi</div> и других языках, но для этого необходимо провести нужную подготовительную работу - создать или найти необходимые файлы 
для разработки и компиляции для этих языков.<br><br>
Decoda - это среда разработки и отладки на <div class="m">Lua</div>. Она позволяет писать и отлаживать скрипты на <div class="m">Lua</div>, при этом Decoda взаимодействует с мад-клиентом 
в процессе отладки. см. описание <a href="#decoda">Decoda</a>.<br><br>
Модули и плагины можно разрабатывать как на <div class="m">C/C++</div>, так и на <div class="m">Lua</div>. Предполагается, что основным языком разработки 
будет <div class="m">Lua</div>, а <div class="m">C/C++</div> будет больше вспомогательным, на котором будут написаны модули.<br>
Все модули и плагины могут взаимодействовать между собой и с самим клиентом, так как они подключены к общему процессору (виртуальной машине) <div class="m">Lua</div>.<br><br>

Различие между модулями и плагинами только в требованиях. У модулей требований нет, кроме как правил написания их для <div class="m">Lua</div>, а для плагины должны реализовать 
определенный набор функций, см. <a href="#pluginsapi">API для плагинов</a>, чтобы с ними мог работать клиент.

<a name="modules"></a>
<h2>Модули</h2>
Модули - это завершенные программные блоки (библиотеки) для использования в клиенте любым другими модулями или плагинами.<br>
Разрабатывать модули можно на любом языке и в основном это не <div class="m">Lua</div>, так как сам Lua - это расширяемый язык и чтобы на нем чтото сделать, нужно реализовать все основные возможности 
на других языках, а с помощью Lua все собрать в одно целое. В основном модули будут написаны на <div class="m">C/C++</div>, так как это необходимо для расширения возможностей <div class="m">Lua</div> в самом клиенте.
<br><br>
Программно все модули полностью соответствуют требованиям API для библиотек для языка <div class="m">Lua</div>. Поэтому можно использовать готовые Lua-библиотеки 
на просторах интернета. А модули, написанные для клиента, можно использовать в других проектах. Следует обратить внимание, что в клиенте используется <div class="m">Lua 5.2</div>.<br><br>
Все модули располагаются в папке <div class="m">modules</div> клиента. Модули на языке <div class="m">Lua</div> (с расширением <div class="m">*.lua</div>) загружаются автоматически при запуске клиента.<br>
Для загрузки модулей на языке <div class="m">C++</div> и возможно других языках, в виде <div class="m">*.dll</div> файлов, нужно воспользоваться функцией <div class="m">require</div> в Lua-скрипте.<br><br>
Пример:
<div class="ee">[local] module = require "module"</div>
Загружаем модуль с именем module.dll в объект-таблицу module. Имя объекта-таблицы можно использовать и другое! Если будет использовано ключевое слово local, 
то модуль будет доступен только в рамках данного Lua - файла, что рекомендуется делать, так как тогда модуль не будет мешать другим модулям (если в них будут использоваться те же самые имена, без слова local, то возникнет конфликт).
Об этом написано в документации к языку.
<a name="plugins"></a>
<h2>Плагины</h2>
Плагины - это специально написанные для мад-клиента программы, которые расширяют и улучшают возможности самого клиента. Плагины можно разрабатывать на любом языке, но в данном SDK 
присутствует возможность написать их на <div class="m">С</div>, <div class="m">С++</div> и <div class="m">Lua</div>.<br><br>
Файлы плагинов располагаются в папке <div class="m">plugins</div> в каталоге клиента. 
Плагины загружаются только тогда, когда разрешит пользователь. Пользователь управляет загрузкой плагинов в клиенте через специально диалоговое окно настроек (см. программу).

<a name="devcpp"></a>
<h2>Разработка на С и С++</h2>
Для разработки модулей-библиотек и плагинов на языке С++ требуется любая среда разработки на данном языке, например <div class="m">Visual Studio</div>, <div class="m">gcc</div>, <div class="m">Borland</div>. Можно разрабатывать библиотеки и 
на других языках, например <div class="m">Delphi</div>, но для этого нужны файлы для компиляции <div class="m">Lua</div> для данной среды разработки. Их можно найти в интернете. Еще также можно использовать уже готовые <div class="m">Lua</div> библиотеки из интернета.<br><br>
В SDK находяться необходимые для компиляции модулей-библиотек файлы. Данные файлы расчитаны на использование <div class="m">Visual Studio 2013</div> (желательно <div class="m">Professional</div> и выше).<br>
Файлы находятся в папке <div class="m">api</div>. Список файлов:
<ul>
<li><div class="m">base.h</div> - заголовочный файл, который нужно включить с помощью #include, если разрабатывается библиотека-модуль.</li>
<li><div class="m">api.h</div> - заголовочный файл, который нужно включить с помощью #include, если разрабатывается плагин.</li>
<li><div class="m">lua.h lualib.h lauxlib.h</div> - заголовочные файлы из библиотеки lua. Это необходимые вспомогательные файлы, которые подключаются в base.h и api.h</li>
<li><div class="m">api.lib lua.lib</div> - файлы для компиляции(библиотеки). Это также необходимые вспомогательные файлы. Они подключаются в base.h и api.h и дополнительно их подключать не требуется.</li>
</ul>
Разница между <div class="m">base.h</div> и <div class="m">api.h</div> в том, что в первом файле подключается только <div class="m">Lua</div>, а во втором еще дополнительно 
добавлено большое количество функций, которые могут понадобиться для плагинов, так называемое <div class="m">API</div>. Модули по идее не должны использовать <div class="m">API</div> клиента, так как они независимые самостоятельные 
библиотеки, которые можно использовать и в других проектах. Однако использовать <div class="m">API</div> клиента в модулях не запрещено, просто тогда модуль не сможет работать отдельно от 
<div class="m">API</div> в других проектах.<br><br>
Включать в проект нужно либо <div class="m">base.h</div>, либо <div class="m">api.h</div>, но не оба одновременно. Другие файлы включать в проект не нужно.<br>
Библиотеки <div class="m">api.lib, lua.lib</div> расчитаны на статическую линковку Runtime библиотеки в проекте.<br>
Для написания и отладки понадобится и сам клиент, так как он и будет подключать плагин/модуль и работать с ним в процессе разработки.<br><br>
Для написания модуля следует ознакомиться с документацией на язык <div class="m">Lua</div>, однако вкратце связь С++ - Lua работает так:<br>
1. У Lua есть параметр типа <div class="m">lua_State</div>, который является указателем на состояние виртуальной машины и он передается во всех функциях.<br>
2. Передача параметров в функцию Lua, а также получение параметров из функции происходит через стек. Для работы со стеком есть набор функций (см. ниже).<br>
3. Каждая функция <div class="m">Lua</div> на языке <div class="m">С/C++</div> выглядит так:
<pre><div class="ee">int function_name(lua_State *L)
{   ...
    return x;
}
</div></pre>
В качестве параметра выступает указатель на состояние виртуальной машины.<br>
Для работы со стеком, чтобы получить параметры, есть следующие основные функции:<br>
<ul>
<li>int lua_gettop(L) - количество параметров в стеке</li>
<li>int lua_isstring(L, index), lua_isnumber(L, index), ... - проверка на тип значения в стеке по заданному индексу</li>
<li>const char* lua_tostring(L, index), int lua_tointeger(L, index), ... - получение значения из стека по индексу нужного типа</li>
<li>void lua_pushstring(L, const char*), void lua_pushinteger(L, int), ... - затолкнуть в стек параметры</li>
<li>void lua_pop(L, count) - извлечь из стека нужное количество параметров</li>
<li>void lua_settop(L, count) - установить количество параметров на стеке (остальные отбросить, если они были)</li>
<li>void lua_newtable(L) - создает новую таблицу</li>
<li>void lua_settable(L, index) - добавляет значение с вершины стека в таблицу в позиции index</li>
</ul>
В качестве возращаемого значения - количество параметров на вершине стека, которые являются результатом работы функции. То есть функция на вершину 
стека должна поместить результат и вернуть количество параметров в результате. Следует заметить, что можно возвращать из функции сразу несколько значений.<br><br>
Взаимодействие с модулем или плагином происходит через объекты и/или функции, которые регистрирует сам модуль в вирутальной машине <div class="m">Lua</div>. Это 
может либо набор отдельных глобальных функций (м.б. и только одна), либо глобальный объект-таблица или несколько объектов-таблиц.<br>
Модуль должен реализовать функцию:<br>
<pre><div class="ee">int luaopen_xxx(lua_State *L)
{ 
  ...
}
</div></pre><br>
Где 'xxx' имя модуля. Именно эту функцию ищет <div class="m">Lua</div> в dll, чтобы загрузить модуль. И данная функция должна зарегистрировать все необходимые функции и объекты,
чтобы Lua могла работать с модулем.<br>
В SDK есть пример модуля на <div class="m">C++</div> (заготовка-шаблон), где продемонстрированы все основные аспекты написания такого модуля.<br><br>
Плагин должен реализовать точно такую же функцию, только с именем <div class="m">plugin_open</div>, чтобы клиент смог его подключить. Список функций которые должны реализовать плагин 
представлены в разделе <a href="#pluginsapi">API для плагинов</a>. В SDK также есть пример плагина на <div class="m">С++</div>, в котором представлены аспекты уже для плагинов.<br><br>
Следующий аспект, который нужно учесть - это кодировка текстовых строк в плагинах и модулях. Это <div class="m">UTF8 !</div> То есть Lua объекты типа string - это строка 
символов в кодировке UTF8. В SDK это решается за счет макроса который включает поддержку этой кодировки в Visual Studio (данный макрос работает только там). При наличии 
этого макроса все ANSI строки в исходных текстах компилируются как UTF8. В <div class="m">API</div> есть вспомогательные функции для работы с кодировками, см. <a href="#api">функции API</a>.

<a name="devlua"></a>
<h2>Разработка на Lua</h2>
Разработка модулей или плагинов на языке <div class="m">Lua</div> очень проста. Для этого нужно написать код модуля в текстовом файле.<br>
Исходный код модуля будет выглядеть примерно так:<br>
<pre><div class="ee">module = {}
module.var = 0
function module.f1()
...
return result
end

function module.f2()
...
end
...
</div></pre><br>
Это объявление пустой таблицы - с именем модуля. Таблица в <div class="m">Lua</div> является основным элементом в языке и используется в том числе для модулей. Далее идут функции модуля 
и его переменные. И это все! Все что требуется, это написать реализацию модуля. (PS. Синтакис исходного кода модуля не обязательно должен быть похожим на пример. В языке <div class="m">Lua</div> 
довольно широкие вариации написания кода. Читайте документацию к языку.)<br><br>
Однако, чтобы на <div class="m">Lua</div> можно чтото сделать, базовые возможности уже должны быть реализованы. Это делается за счет других модулей. Если имеющихся возможностей не будет хватать, 
то их придется предварительно реализовать на <div class="m">С++</div> или взять готовый модуль из интернета. Модуль использует другой модуль - это принцип, который заложен в данный клиент, и
его нужно использовать. Это дает возможность для быстрого развития самого клиента.<br><br>
Написание плагинов не сложнее, чем написание модулей. Код плагина будет выглядеть примерно так:<br>
<pre><div class="ee">plugin = {}
plugin.var = 0
function plugin.name()
return "Фильтр чата"
end

function plugin.description()
return "Данный плагин позволяет..."
end

function plugin.version()
return "1.0"
end

function plugin.init()
...
end
...
</div></pre>
Для плагинов есть дополнительно набор требований (см. <a href="#pluginsapi">API для плагинов</a>), а в остальном они полностью идентичны модулям.
<br><br>
<div class="t">Правила при написании модулей и плагинов на Lua:</div>
<ul>
<li>Текстовый файл с исходным кодом должен быть в кодировке <div class="m">UTF8</div>. В данном файле должен присутствовать маркер <div class="m">BOM</div> для файлов в UTF8.</li>
<li>Весь код должен быть в рамках объектов-таблиц и функций, которые являются частью этой таблицы:<br>
<pre><div class="ee">module = {} -- объект-таблица модуля
module.var = 0 -- переменная модуля
function module.f1() -- функция модуля
end

a = 10 -- оператор вне функции, так писать крайне не рекомедуется
f(10,20) -- вызов другой функции (не рекомендуется)

local b = 20 -- правильное написание
local t = {...} -- правильное написание
</div></pre></li>
Писать код вне функций не рекомендуется, так как этот код запускается в момент загрузки файла с исходным кодом в Lua - процессор (виртуальную машину). 
Последовательность загрузки модулей в клиенте может быть абсолютно любой, поэтому нет никаких гарантий, что в момент выполнения такого кода, все необходимые модули уже будут загружены. 
Для переменных вне функций следует использовать ключевое слово local, чтобы их ограничить рамками файла (иначе они будут глобальными для всей Lua-машины и возникнет вероятность конфликта 
между модулями и плагинами). Тоже самое относится к вспомогательным таблицам модуля (используйте local).
<li>Название файла с исходным текстом модуля или плагина должно совпадать с названием самого модуля или плагина, чтобы не было путаницы в файлах.</li>
</ul>

<a name="pluginsapi"></a>
<h2>Функции взаимодействия клиента с плагином, API плагина</h2>
В данном разделе представлены все функции, которые должны/могут быть реализованы на стороне плагина. Данные функции вызывает клиент. Когда эти функции будут вызваны описаны в самих функциях.<br>

<h3>Приоритетные функции</h3>
В работе плагинов есть понятие <div class="m">приоритета</div> и <div class="m">приоритетные функции</div>. Данные функции вызываются в том порядке, в котором указаны плагины в клиенте (см. программу). 
Эти функции используются при обработке данных мада в плагине и данные поступают от одного плагина к другому по цепочке(по приоритету), которую указал игрок в настройках. Это нужно учитывать 
при подключении плагинов.
<br><br>
<h3>Обзязательные функции плагина</h3>
Эти функции обязательны для плагина (без них клиент не будет работать с плагином):
<hr>
<h4>string name()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: строка<br></div><br>
Функция должна возвратить название плагина.
<hr>
<h4>string description()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: строка<br></div><br>
Функция должна возвратить подробное описание плагина  (что он делает и для чего предназначен).
<hr>
<h4>string version()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: строка<br></div><br>
Функция должна возвратить версию плагина.
<hr>
<h3>Используемые функции плагина</h3>
Эти функции можно использовать при необходимости. Функции будут вызываться, если они реализованы в плагине.
<a name="init"></a>
<h4>init()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: нет<br></div><br>
Функция вызывается в момент загрузки плагина. Предназначена для того, чтобы плагин настроил все необходимое для своей работы (например добавил пункт меню, см. <a href="#clientapi">API клиента</a>).
<hr>
<a name="release"></a>
<h4>release()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: нет<br></div><br>
Функция вызывается в момент выгрузки плагина из клиента и памяти компьютера. Предназначена для того, чтобы плагин сохранил все данные и освободил ресурсы. 
Пункты меню и кнопки панели управления удалять не нужно (удаляются автоматически клиентом).
<hr>
<a name="menucmd"></a>
<h4>menucmd(int id)</h4>
<div class="m">Параметры: id - целочисленное число</div><br>
<div class="m">Результат: нет<br></div><br>
Клиент вызывает данную функцию, когда пользователь выбирает пункт меню или нажимает кнопку на панели управления, которые относятся к плагину.
В качестве id возвращается идентификатор, который использовался при создании пункта меню или кнопки.
<hr>
<a name="closewindow"></a>
<h4>closewindow(int hwnd)</h4>
<div class="m">Параметры: hwnd - дескриптор окна</div><br>
<div class="m">Результат: нет<br></div><br>
Функция вызывается в момент закрытия окна плагина (если плагин создает окна, по клику на крестике окна плагина). 
В качестве параметра возращается число - дескриптор окна плагина.
<br>См.также: <a href="#createwindow" class="cmd">createWindow</a>
<hr>
<a name="streamdata"></a>
<h4>string streamdata(string stream)</h4>
<div class="e">Приоритетная функция</div><br>
<div class="m">Параметры: stream - строка, входной поток байт</div><br>
<div class="m">Результат: строка - выходной поток байт<br></div><br>
Функция предназначена для работы с потоком байт, который идет от мад сервера. В метод попадают данные так, как они приходят от мад сервера без 
предварительной обработки. Единственное, что делает клиент - работает со сжатием mccp(если включено), обрабатывает IAC TELNET опции, преобразует данные из 
кодировки сервера в кодировку UTF8. После этого данные попадают в этот метод.<br><br>
Функция обязательно должна вернуть строку - выходной поток данных. Если плагину необходимо изменить этот поток байт, то он может это сделать и вернуть 
уже другие данные. Если изменять данные не нужно, то необходимо вернуть строку-параметр с исходным потоком.
<hr>
<a name="barcmd"></a>
<h4>table barcmd(table сmds)</h4>
<div class="e">Приоритетная функция</div><br>
<div class="m">Параметры: cmds - таблица Lua со списком всех команд</div><br>
<div class="m">Результат: таблица - список команд после обработки<br></div><br>
Функция предназначена для работы со всеми командами, которые вводит пользователь в командной строке клиента. Она вызывается сразу же после ввода команды, еще 
до какой-либо обработки со стороны клиента. Клиент передает в функцию таблицу Lua, в которой перечислены все команды из командной строки 
(клиент разбивает строку на отдельные команды, если введено сразу несколько). Функция может изменить список команд. Если функция не меняет что-то в этом 
списке, то она должна вернуть исходную таблицу.
<hr>
<a name="historycmd"></a>
<h4>bool historycmd(string сmd)</h4>
<div class="e">Приоритетная функция</div><br>
<div class="m">Параметры: cmd - команда</div><br>
<div class="m">Результат: true/false<br></div><br>
Функция предназначена для работы с историей команд клиента. Данная функция вызывается для каждой команды, которую вводит пользователь (после <a href="#barcmd" class="cmd">#barcmd</a>). 
В качестве результата она должна вернуть булевское значение, которое означает <div class="m">false</div> - не записывать команду в историю клиента, <div class="m">true</div> - 
команду нужно записать. Клиент прекращает дальнейший вызов данной функции у плагинов, если возращается <div class="m">false</div>.
<hr>
<a name="gamecmd"></a>
<h4>string gamecmd(string сmd)</h4>
<div class="e">Приоритетная функция</div><br>
<div class="m">Параметры: cmd - строка, игровая команда</div><br>
<div class="m">Результат: строка - игровая команда<br></div><br>
Функция предназначена для работы с игровыми командами игрока (которые будут отправлены на мад-сервер). Сюда попадают все игровые команды, которые вводятся игроком или как результат работы триггеров. 
Плагин может, при необходимости изменить команду, или даже ее отбросить. Функция должна вернуть исходную команду, если плагин не изменяет команду, или новую версию команды. 
В функцию попадает только одна команда, уже после всех обработок клиентом и готовая к отправке на сервер. Если нужно обрабатывать команды, которые вводит пользователь, см. 
<a href="#barcmd" class="cmd">#barcmd</a>

<hr>
<a name="syscmd"></a>
<h4>string syscmd(string сmd)</h4>
<div class="e">Приоритетная функция</div><br>
<div class="m">Параметры: cmd - строка, системная команда</div><br>
<div class="m">Результат: строка - системная команда<br></div><br>
Функция предназначена для работы с системными командами (команды клиента, которые начинаются с символа #). Сюда попадают все системные команды,  которые вводятся игроком или как результат работы триггеров. 
Плагин может, при необходимости изменить команду, или даже ее отбросить. Функция должна вернуть исходную команду, если плагин не изменяет команду, или новую версию команды. 
Команда попадает в метод без ведущего символа системной команды #. В функцию попадает только одна команда, уже после всех обработок клиентом и готовая к выполнению клиентом. 
Если нужно обрабатывать команды, которые вводит пользователь, см. <a href="#barcmd" class="cmd">#barcmd</a>

<hr>
<a name="before"></a>
<h4>before(int view, viewdata data)</h4>
<div class="e">Приоритетная функция</div><br>
<div class="m">Параметры: view - индекс окна, data - объект-массив, со строками</div><br>
<div class="m">Результат: нет<br></div><br>
Функция предназначена для работы с данными, которые приходят от мад-сервера в виде массива строк (клиент уже сформировал набор строк). Метод вызывается ДО (before) вызова обработчиков 
триггиров, подсветок, замен и других элементов. Он может использоватся как фильтр (удалять или заменять строки, менять цвет) или работать без изменения строк. 
В качестве первого параметра - индекс окна, для которого предназначен массив строк ( 0 - это главное окно мад-клиента, 1 и больше - это output окна клиента). 
В качестве второго параметра выступает специальный объект-массив, с помощью которого можно работать с массивом строк.
<br>См.также: <a href="#viewdata" class="cmd">viewdata</a>, <a href="#cppviewdata" class="cmd">viewdata в С++</a>.
<hr>
<a name="after"></a>
<h4>after(int view, viewdata data)</h4>
<div class="e">Приоритетная функция</div><br>
<div class="m">Параметры: view - индекс окна, data - объект-массив, со строками</div><br>
<div class="m">Результат: нет<br></div><br>
Функция идентична команде <a href="#before" class="cmd">before</a>, только она работает ПОСЛЕ (after) обработчиков триггиров, подсветок, замен и др. элементов. После этого метода 
строки попадают в главное окно мада или output-окно.
<br>См.также: <a href="#viewdata" class="cmd">viewdata</a>, <a href="#cppviewdata" class="cmd">viewdata в С++</a>.
<hr>
<a name="clientapi"></a>
<h2>Функции взаимодействия плагина с клиентом, API клиента</h2>
<div class="m">API клиента</div> делиться на 2 части:
<ul>
<li><a href="#cppapi">С++ API</a> - представлена в файле <div class="m">api.h</div>, который входит в состав SDK.</li>
<li><a href="#luaapi">Lua API</a> - интегрирована в виртуальную машину клиента и доступна как из C++, так и Lua.</li>
</ul>
<a name="cppapi"></a>
<h3>API клиента C++</h3>
Все необходимое API для разработки плагинов находится в <div class="m">api.h</div>, его можно открыть и посмотеть подробно. В этом разделе 
представлено описание содержимого данного файла. Другой файл <div class="m">base.h</div> подключает <div class="m">API Lua</div> 
и с этой частью можно познакомиться в документации к языку.<br><br>
В плагинах используется кодировка <div class="m">UTF8</div>, обратите внимание! Это достигается за счет макроса в файле <div class="m">base.h</div>. 
Все ansi-строки в исходных текстах, при наличии макроса, компилируются как UTF8. Данный макрос работает только в Visual Studio.
<hr>
<h4>bool  luaT_check(lua_State *L, int n, ...);</h4>
<div class="m">Параметры: n - количество параметров, ... - параметры</div><br>
<div class="m">Результат: true/false<br></div><br>
Функция проверяет состояние стека Lua машины на соответствие параметрам. Нужно указать количество параметров и их типы. Функция 
предназначена для выбора нужной ветки кода в зависимости от параметров в С++ обработчиках вызовов со стороны Lua.
<hr>
<h4>bool  luaT_run(lua_State *L, const utf8* func, const utf8* op, ...);</h4>
<div class="m">Параметры: func - название функции для запуска, op - количество и число параметров, ... - параметры</div><br>
<div class="m">Результат: true/false<br></div><br>
Функция запускает Lua-функцию с заданным именем. Следующий параметр определяет количество и число параметров (одна буква - один параметр):
<ul>
<li>d - целое число (int)</li>
<li>s - строка (utf8)</li>
<li>o - объект, данный символ может быть только в первой позиции, сам объект нужно предварительно поместить в стек через luaT_pushobject</li>
<li>u - беззнаковое целое число (unsigned int)</li>
</ul>
Далее, после строки с типом и числом параметров, идут сами параметры.
<hr>
<h4>int luaT_error(lua_State *L, const utf8* error_message);</h4>
<div class="m">Параметры: error_message - сообщение об ошибке</div><br>
<div class="m">Результат: число - значение с числом параметров на стеке, предназначено для передачи в Lua<br></div><br>
Функция предназначена для завершения какой-либо другой функции, в случае ошибки. Сообщение об ошибке передается в клиент, где и отображается.<br>
Пример:
<pre><div class="ee">int f(lua_State *L)
{ ...
  if (error) 
    return luaT_error('Ошибка');
  ...
}
</div></pre>
<hr>
<h4>void luaT_log(lua_State *L, const utf8* log_message);</h4>
<div class="m">Параметры: log_message - сообщение для пользователя</div><br>
<div class="m">Результат: нет<br></div><br>
Функция предназначена для вывода логов в окно клиента. В настройках клиента указывается окно в которое нужно их выводить.
<h3>API клиента Lua</h3>
<hr>
<h4>void* luaT_toobject(lua_State* L, int index);</h4>
<div class="m">Параметры: index - позиция в стеке Lua</div><br>
<div class="m">Результат: указатель на объект<br></div><br>
Функция возвращает указатель на объект по заданному индексу в стеке. Если это не объект, то возвращается NULL.<br>
<hr>
<h4>void luaT_pushobject(lua_State* L, void *object, int type);</h4>
<div class="m">Параметры: object - указатель на объект, type - тип объекта</div><br>
<div class="m">Результат: нет<br></div><br>
Помещает в стек Lua объект (его указатель) заданного типа.
<hr>
<h4>bool luaT_isobject(lua_State* L, int type, int index);</h4>
<div class="m">Параметры: type - тип объекта, index - позиция в стеке</div><br>
<div class="m">Результат: true/false<br></div><br>
Проверяет, что на стеке Lua находится объект заданного типа.
<hr>
<h4>void luaT_showLuaStack(lua_State* L, const char* label);</h4>
<div class="m">Параметры: label - текстовая метка</div><br>
<div class="m">Результат: нет<br></div><br>
Функция предназначена для отладки плагинов. Она через метод Win32API OutputDebugString выводит содержимое стека Lua на момент вызова. 
Эта информация попадает в отладчик C++. Эту информацию можно увидеть и с помощью программы <a href="http://technet.microsoft.com/en-us/sysinternals/bb896647.aspx" target="_blank">DebugView</a>, 
при условии что отладчик не работает (он перехватывает OutputDebugString). Текстовая метка используется для идентификации нужного вызова метода.
<hr>
<h4>void luaT_showTableOnTop(lua_State* L, const char* label);</h4>
<div class="m">Параметры: label - текстовая метка</div><br>
<div class="m">Результат: нет<br></div><br>
Функция предназначена для отладки плагинов. Она через метод Win32API OutputDebugString выводит содержимое таблицы на вершине стека Lua на момент вызова. 
см. <div class="m">luaT_showLuaStack</div>.
<hr>
<a name="luatwindow"></a>
<h4>class luaT_window</h4>
Любой плагин, при необходимости может создавать для себя дополнительные окна. Данный класс предназначен для облегчения решения этой задачи. 
Класс является оберткой вокруг Lua объекта Окно. В Lua есть подобный интерфейс <a href="#window" class="cmd">window</a>.<br>
<pre>
<div class="cmd">void init(lua_State *pL, void *window_object)</div> - инициализация.
<div class="cmd">HWND hwnd()</div> - получение заголовка окна.
<div class="cmd">void hide()</div> - скрыть окно.
<div class="cmd">void show()</div> - показать окно.
<div class="cmd">bool isvisible()</div> - проверка видидимо окно или нет.
<div class="cmd">void attach(HWND child)</div> - подключение к окну клиента своего окна.
</pre>
<hr>
<a name="cppviewdata"></a>
<h4>class luaT_ViewData</h4>
Класс предназначен для манипуляции со строками, которые плагин получает от клиента. Используется при работе с методами <a href="#before" class="cmd">before</a> и 
<a href="#after" class="cmd">after</a>. В Lua есть подобный интерфейс <a href="#viewdata" class="cmd">viewdata</a>
<br><div class="m">Внимание!</div> Все индексы начинаются с 1, а не с 0, т.е рабочий диапозон индексов [1..n]. Решение связано с интеграцией с языком Lua.
<pre>
<div class="cmd">void init(lua_State *pL, void *viewdata)</div> - инициализация.
<div class="cmd">int  size()</div> - количество строк.
<div class="cmd">bool select(int index)</div> - выбор строки для дальнейшей работы.
<div class="cmd">int  getindex()</div> - индекс текущей строки.
<div class="cmd">bool isfirst()</div> - первая строка является продолжением последней строки (завершение предыдущей строки).
<div class="cmd">bool isgamecmd()</div> - в строке присутствует игровая команда.
<div class="cmd">bool isprompt()</div> - это prompt строка.
<div class="cmd">void getprompt(u8string *str)</div> - возвращает prompt-строку (без возможных команд в строке).
<div class="cmd">void gettext(u8string* str)</div> - полный текст строки (без учета расцветки).
<div class="cmd">int  gettextlen()</div> - длина всей строки в символах (без учета расцветки).
<div class="cmd">void gethash(u8string* str)</div> - хэш сумма строки. Используется для быстрого сравнения строк.
<div class="cmd">int  blocks()</div> - количество отдельных блоков в текущей строке.
<div class="cmd">bool get(int block, int param, unsigned int *value)</div> - значение параметра блока текущей строки. Допустимые значения параметра:
<div class="m">TEXTCOLOR</div>, <div class="m">BKGCOLOR</div>, <div class="m">UNDERLINE</div>, <div class="m">ITALIC</div>, <div class="m">BLINK</div>, <div class="m">REVERSE</div>, <div class="m">EXTTEXTCOLOR</div>, <div class="m">EXTBKGCOLOR</div>.
<div class="cmd">bool set(int block, int param, unsigned int value)</div> - устанавливает значение параметра блока текущей строки.
<div class="cmd">void getblocktext(int block, u8string* str)</div> - текст блока текущей строки.
<div class="cmd">bool setblocktext(int block, const utf8* text)</div> - задает новый текст блоку текущей строки.
<div class="cmd">bool copyblock(int block, int dst_string, int dst_block)</div> - копирует заданный блок текущей строки в другую строку.
<div class="cmd">bool deleteblock(int block)</div> - удаляет блок текущей строки.
<div class="cmd">bool deleteallblocks()</div> - удаляет все блоки, остается пустая строка.
<div class="cmd">bool createstring()</div> - создает новую пустую строку. Строка добавляется между текущей строкой и следующей за ней.
<div class="cmd">bool deletestring()</div> - удаляет текущую строку.
</pre>
<hr>
<a name="cppactobj"></a>
<h4>class luaT_ActiveObjects</h4>
Класс предназначен для манипуляции с объектам клиента. <a href="#luaactobj" class="cmd">Подобная возможность</a> в Lua.<br>
Поддеживаемые типы объектов:
<ul>
<li><div class="m">aliases</div> - макросы</li>
<li><div class="m">actions</div> - триггеры</li>
<li><div class="m">subs</div> - замены</li>
<li><div class="m">antisubs</div> - антизамены</li>
<li><div class="m">highlights</div> - подсветки</li>
<li><div class="m">hotkeys</div> - горячие клавиши</li>
<li><div class="m">gags</div> - фильтры</li>
<li><div class="m">vars</div> - переменные</li>
<li><div class="m">groups</div> - группы</li>
<li><div class="m">timers</div> - таймеры</li>
<li><div class="m">tabs</div> - подстановки</li>
</ul>
<br><div class="m">Внимание!</div> Все индексы начинаются с 1, а не с 0, т.е рабочий диапозон индексов [1..n]. Решение связано с интеграцией с языком Lua.
<pre>
<div class="cmd">luaT_ActiveObjects(lua_State *pL, const char* type)</div> - инициализация (конструктор), возможные типы см. выше.
<div class="cmd">int  size()</div> - количество элементов.
<div class="cmd">bool select(int index)</div> - выбор нужного элемента по индексу.
<div class="cmd">bool add(const utf8* key, const utf8* value, const utf8* group)</div> - добавление нового элемента.
<div class="cmd">bool del()</div> - удаление текущего элемента.
<div class="cmd">int  getindex()</div> - получение позиции текущего элемента.
<div class="cmd">bool setindex(int index)</div> - переместить текущий элемент в нужную позицию.
<div class="cmd">bool get(int param, u8string* value)</div> - получить параметр текущего элемента. Возможные варианты параметра:
<div class="m">KEY</div>, <div class="m">VALUE</div>, <div class="m">GROUP</div>.
<div class="cmd">bool set(int param, const utf8* value)</div> - установка нужного параметра у текущего элемента.
<div class="cmd">bool update()</div> - применить все изменения. Только после вызова этого оператора все изменения вступят в силу.
</pre>
<hr>
<h4>Преобразование кодировок</h4>
В <div class="m">API</div> клиента есть методы для переобразования текста между различными кодировками.<br>
<pre>
<div class="cmd">const wchar_t* convert_utf8_to_wide(const utf8* string);</div> - конвертация строки из UTF8 в UTF16
<div class="cmd">const utf8* convert_wide_to_utf8(const wchar_t* string);</div> - конвертация строки из UTF16 в UTF8
<div class="cmd">const wchar_t* convert_ansi_to_wide(const char* string);</div> - конвертация строки из ANSI в UTF16
<div class="cmd">const char* convert_wide_to_ansi(const wchar_t* string);</div> - конвертация строки из UTF16 в ANSI
</pre>
<hr>
<h4>Работа с XML</h4>
В <div class="m">API</div> клиента есть возможность работать с <div class="m">XML</div>.<br>

<h4>class xml::node</h4>
Класс представляет собой обертку вокруг методов работы с вершиной <div class="m">XML</div> документа.
<pre>
<div class="cmd">node(const utf8* rootnode)</div> - создание нового документа с заданным именем корнего узла
<div class="cmd">node(xnode xml_node)</div> - подключение обертки к вершине
<div class="cmd">bool load(const utf8 *filename)</div> - загрузка в вершину xml-файла
<div class="cmd">bool save(const utf8 *filename)</div> - запись вершины в xml-файл
<div class="cmd">void deletenode()</div> - удалить вершину.
<div class="cmd">void getname(u8string *name)</div> - имя вершины.
<div class="cmd">bool get(const utf8* attribute, u8string* value)</div> - атрибут вершины.
<div class="cmd">bool get(const utf8* attribute, int* value)</div> - атрибут вершины в виде числа.
<div class="cmd">bool get(const utf8* attribute, std::wstring* value)</div> - атрибут вершины в виде строки UTF16.
<div class="cmd">void set(const utf8* attribute, const utf8* value)</div> - задать атрибут.
<div class="cmd">void set(const utf8* attribute, int value)</div> - задать атрибут в виде числа.
<div class="cmd">void set(const utf8* attribute, const std::wstring& value)</div> - задать атрибут в виде строки UTF16.
<div class="cmd">void gettext(u8string *text)</div> - текст вершины.
<div class="cmd">void settext(const utf8* text)</div> - задать текст вершины.
<div class="cmd">xml::node createsubnode(const utf8* name)</div> - создать дочернюю вершину.
<div class="cmd">int  size()</div> - количество атрибутов у вершины.
<div class="cmd">bool getattrname(int index, u8string* value)</div> - имя атрибута по индексу.
<div class="cmd">bool getattrvalue(int index, u8string* value)</div> - значение атрибута по индексу.
<div class="cmd">bool move(const utf8* path)</div> - переместить вершину в другую позицию по заданному пути.
<div class="cmd">bool create(const utf8* path)</div> - создать вершину по заданному пути.
</pre>
<h4>class xml::request</h4>
Класс позволяет делать выборку нужных вершин по выражению. Похоже на запрос к базе данных.
<pre>
<div class="cmd">request(xnode node, const utf8 *request_string)</div> - выбрать нужные дочерние вершины у текущей вершины по выражению.
<div class="cmd">request(xml::node& node, const utf8 *request_string)</div> - выбрать нужные дочерние вершины у текущей вершины по выражению.
<div class="cmd">int  size()</div> - количество вершин в выборке.
<div class="cmd">bool empty()</div> - проверка, что выборка пустая.
<div class="cmd">xml::node operator[](int node_index)</div> - получить вершину выборки по индексу.
</pre>
<hr>
<h4>Работа с регулярными выражениями</h4>
В <div class="m">API</div> клиента есть методы работы с текстами посредством регулярных выражений. Используется <a href="http://www.pcre.ru/" target="_blank">PCRE</a> диалект.<br>
<h4>class Pcre</h4>
В регулярных выражениях круглые скобки <div class="m">'()'</div> имеют особый смысл. Они используются для выделения интересующей части искомой строки.<br>
Методы <div class="cmd">first</div>, <div class="cmd">last</div>, <div class="cmd">size</div> используются для работы с такими скобками. См. документацию 
по PCRE.
<pre>
<div class="cmd">bool init(const utf8* _rgxp)</div> - инициализация регулярным выражением.
<div class="cmd">bool find(const utf8* string)</div> - поиск в строке по регулярному выражению.
<div class="cmd">bool findall(const utf8* string)</div> - поиск всех подстрок в стоке по регулярному выражению.
<div class="cmd">int  size()</div> - количество найденных параметров в круглых скобках.
<div class="cmd">int  first(int index)</div> - начальная позиция в строке (индекс символа) по индексу параметра, с которого начинается 
совпадение по регулярному выражению.
<div class="cmd">int  last(int index)</div> - конечная позиция в строке (индекс символа+1), на котором заканчивается совпадение по регулярному выражению.
<div class="m">Замечание:</div> Если поиск производился методом <div class="cmd">find</div>, то по индексу <div class="m">0</div> будут получены границы совпадения всего регулярного выражения?
а с индекса <div class="m">1</div> начнутся границы совпадения для круглых скобок <div class="m">'()'</div> из регулярного выражения.
<div class="cmd">void getstring(int index, u8string *str)</div> - получить строку, которая находится в границах по заданному индексу.
</pre>
<hr>
<a name="luaapi"></a>
<h3>API клиента Lua</h3>
В данно разделе представлен набор функций, которые встроены в виртуальную машину Lua клиента.<br>
Подключены:
<ul>
<li>Все стандартные методы Lua, функции: <div class="m">assert</div>, <div class="m">type</div>, <div class="m">tonumber</div>, <div class="m">tostring</div> и другие (см. документацию к <div class="m">Lua</div>).</li>
<li>Методы по работе таблицами: <div class="m">table.sort</div>, <div class="m">table.insert</div>, <div class="m">table.remove</div>, <div class="m">table.concat</div>, и др.</li>
</ul>
Также подключены и функции <div class="m">API</div>. Данные методы доступны и из <div class="m">С++</div> кода с помощью метода <div class="cmd">luaT_run</div>. Если 
понять механизм взаимосвязи C++ - Lua, то можно вызывать любые функции Lua из кода С++.
<hr>
<h4>void addCommand(string cmd)</h4>
<div class="m">Параметры: cmd - системная команда</div><br>
<div class="m">Результат: нет<br></div><br>
Функция добавляет в клиент новую системную команду (через '#'). Данная команда будет участвовать в автоподстановках.
Через метод <a href="#syscmd" class="cmd">syscmd</a> плагин может реализовать функционал команды. Данная функция расчитана на 
использовании в методе <a href="#init" class="cmd">init</a>. Системная команда автоматически удаляется, в момент выгрузки плагина.
<hr>
<h4>void addMenu(string path, int id, int pos)</h4>
<div class="m">Параметры: path - путь, id - идентификатор, pos - позиция</div><br>
<div class="m">Результат: нет<br></div><br>
Функция добавляет в меню клиента новый пункт меню. Параметр path определяет метоположение пункта меню. Последнее слова в пути - это название пунка меню. 
id - идентификатор, который будет передан в функцию <a href="#menucmd" class="cmd">menucmd</a>, pos - местоположение пункта меню относительно других. 
Пункт меню автоматически удаляется при выгрузке плагина, функция расчитана на использование в методе <a href="#init" class="cmd">init</a>.<br>
Пример:
<pre><div class="ee">function plugin.init()
...
addMenu('Справочник/База предметов', 100, 1)
...
end
</div></pre>
Пример создаст пункт меню: 'Справочник' в главном меню, 'База предметов' - пункт в этом меню, идентификатор пункта 100, пункт 'Справочник' - будет на 
первой позиции в главном меню.
<hr>
<h4>void addButton(int bmp, int id, string tooltip)</h4>
<div class="m">Параметры: bmp - идентификатор картинки, id - идентификатор команды, tooltip - подсказка</div><br>
<div class="m">Результат: нет<br></div><br>
Функция добавляет кнопку на панель инструментов клиента. Картинка загружается из ресурсов плагина. 
id - идентификатор, который будет передан в функцию <a href="#menucmd" class="cmd">menucmd</a>, tooltip - всплывающая подсказка, при наведении стрелки 
мыши на кнопку. Кнопка автоматически удаляется при выгрузке плагина, функция расчитана на использование в методе <a href="#init" class="cmd">init</a>. 
Картинка должна быть в формате <div class="m">BMP</div>.
<br>
<div class="m">Замечание:</div> загрузка картинки для Lua плагина (из файла) пока не реализована.
<hr>
<h4>void addToolbar(string name [,int buttons_size])</h4>
<div class="m">Параметры: name - название, buttons_size - размер кнопок (необязательный параметр)</div><br>
<div class="m">Результат: нет<br></div><br>
Функция создает новую панель инструментов (тулбар) с заданным именем. Дополнительно можно указать размер картинок, которые будут использоваться 
в кнопках на данном тулбаре. После создания, все последующие вызовы метода <div class="cmd">addButton</div> будут добавлять кнопки на данный тулбар. 
Тулбар автоматически удаляется при выгрузке плагина, функция расчитана на использование в методе <a href="#init" class="cmd">init</a>. 
<hr>
<h4>void hideToolbar(string name)</h4>
<div class="m">Параметры: name - название</div><br>
<div class="m">Результат: нет<br></div><br>
Функция скрывает панель инструментов (тулбар) с заданным именем.
<hr>
<h4>void showToolbar(string name)</h4>
<div class="m">Параметры: name - название</div><br>
<div class="m">Результат: нет<br></div><br>
Функция включает отображение панели инструментов (тулбар) с заданным именем.
<hr>
<h4>void checkMenu(int id)</h4>
<div class="m">Параметры: id - идентификатор</div><br>
<div class="m">Результат: нет<br></div><br>
Функция переводит пункт меню или кнопки в состояние checked. Нужно передать идентификатор пункта меню или кнопки.
<hr>
<h4>void uncheckMenu(int id)</h4>
<div class="m">Параметры: id - идентификатор</div><br>
<div class="m">Результат: нет<br></div><br>
Функция снимает с пункта меню или кнопки состояние checked. Нужно передать идентификатор пункта меню или кнопки.
<hr>
<h4>void enableMenu(int id)</h4>
<div class="m">Параметры: id - идентификатор</div><br>
<div class="m">Результат: нет<br></div><br>
Функция переводит пункт меню или кнопку в состояние активно. Нужно передать идентификатор пункта меню или кнопки.
<hr>
<h4>void disableMenu(int id)</h4>
<div class="m">Параметры: id - идентификатор</div><br>
<div class="m">Результат: нет<br></div><br>
Функция блокирует пункт меню или кнопку (состояние заблокировано). Нужно передать идентификатор пункта меню или кнопки.
<hr>
<h4>string getPath(string file)</h4>
<div class="m">Параметры: file - относительный путь к файлу</div><br>
<div class="m">Результат: полный путь к файлу<br></div><br>
Функция расчитывает полный путь к файлу по его относительному пути. Функция использует для расчта имя группы профилей, 
чтобы плагин мог работать с разными профилями.
<hr>
<h4>string getProfile()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: имя текущего профиля<br></div><br>
Функция возвращает имя текущего профиля.
<hr>
<h4>HWND getParent()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: хэндл окна клиента<br></div><br>
Функция возвращает идентификатор - хэндл окна мад клиента в Windows. Используется для работы с окнами в плагинах с интерфейсом.
<hr>
<h4>window createWindow(string title, [int width, int height])</h4>
<div class="m">Параметры: title - заголовок окна, width,height - ширина и высота окна</div><br>
<div class="m">Результат: объект окно (window)<br></div><br>
Функция создает дополнительное окно (для отображения любой информации) - <a href="#window" class="cmd">window</a>. В качестве 
параметров - заголовок окна и размеры окна (ширина и высота).
<hr>
<h4>void log(string message)</h4>
<div class="m">Параметры: message - текст сообщения</div><br>
<div class="m">Результат: нет<br></div><br>
Функция предназначена для вывода строки с логом в окно клиента. Окно вывода указывается в настройках клиента.
<hr>
<a name="window"></a>
<h4>window</h4>
Данный объект не является глобальным, это результат работы функции <div class="cmd">createWindow</div>. Он является тем же интерфейсом, 
что и <a href="#luatwindow" class="cmd">luaT_window</a> на стороне С++.
<pre>
<div class="cmd">void attach(HWND child)</div> - подключение окна плагина в окно клиента.
<div class="cmd">HWND hwnd()</div> - возвращает хэндл окна клиента.
<div class="cmd">void dock(string side)</div> - заставляет окно пристыковаться к нужной стороне клиента. Возможные варианты: 'left', 'right', 
'top', 'bottom'.
<div class="cmd">void undock()</div> - окно открепляется от окна клиента.
<div class="cmd">void block(string side)</div> - блокировка возможности прикрепить окно к определенной стороне. Возможные варианты: 'left', 
'right', 'top', 'bottom', 'float'. Вариант 'float' означает, что окно не может быть плавающим и всегда должно быть пристыкованным.
<div class="cmd">void show()</div> - отображает окно.
<div class="cmd">void hide()</div> - скрывает окно.
<div class="cmd">bool isvisible()</div> - возвращает статус видимо окно или нет.
</pre>

<hr>
<a name="luaactobj"></a>
<h4>Манипуляции с объектам клиента.</h4>
Данные функции(объекты) предназначены для манипуляции с триггерами, макросами и др. элементами клиента. Данное описание 
корелируется с классом <a href="#cppactobj" class="cmd">luaT_ActiveObjects</a>, так как они предназначены для одно и того же.<br><br>
Доступ из скриптов Lua идет через использование глобальных объектов:
<ul>
<li><div class="m">aliases</div> - макросы</li>
<li><div class="m">actions</div> - триггеры</li>
<li><div class="m">subs</div> - замены</li>
<li><div class="m">antisubs</div> - антизамены</li>
<li><div class="m">highlights</div> - подсветки</li>
<li><div class="m">hotkeys</div> - горячие клавиши</li>
<li><div class="m">gags</div> - фильтры</li>
<li><div class="m">vars</div> - переменные</li>
<li><div class="m">groups</div> - группы</li>
<li><div class="m">timers</div> - таймеры</li>
<li><div class="m">tabs</div> - подстановки</li>
</ul>
<div class="m">Внимание!</div> Все индексы начинаются с 1, а не с 0, как это принято в языке Lua.
<br><br>Данные объекты полностю идентичны, и это список их функций:
<pre>
<div class="cmd">int  size()</div> - возвращает число элементов.
<div class="cmd">bool select(int index)</div> - выбор элемента для работы.
<div class="cmd">bool set(string type, string value)</div> - задает значение атрибута для текущего элемента.
Возможные варианты атрибута: 'key', 'value', 'group'.
<div class="cmd">string get(string type)</div> - возвращает значения атрибута. Если атрибут неверный, возвращается nul.
<div class="cmd">bool add(string key[ ,string value, string group])</div> - добавляет новый элемент. Если не указана группа, то 
элемент добавляется в первую группу.
<div class="cmd">bool delete()</div> - удаляет текущий элемент.
<div class="cmd">int  getindex()</div> - возвращает индекс-приоритет текущего элемента.
<div class="cmd">bool setindex(int index)</div> - установка текущего приоритета у текущего элемента.
</pre>
Пример (добавить макрос есть):
<pre><div class="ee">aliases.add("есть", "съесть хлеб", "default")
</div></pre>
<hr>
<a name="viewdata"></a>
<h4>viewdata</h4>
Объект, который не является глобальным, используется при работе с методами <a href="#before" class="cmd">before</a> и 
<a href="#after" class="cmd">after</a>. Он предназначен для манипуляции со строками, которые плагин получает от клиента 
через эти методы. В C++ есть подобный интерфейс <a href="#cppviewdata" class="cmd">luaT_ViewData</a>.
<br><div class="m">Внимание!</div> Все индексы начинаются с 1, а не с 0, как это принято в языке Lua.
<pre>
<div class="cmd">int  size()</div> - возвращает количество строк в коллекции.
<div class="cmd">bool select(int index)</div> - выбор текущей строки для работы.
<div class="cmd">int  getindex()</div> - индекс текущей строки.
<div class="cmd">bool isfirst()</div> - возвращает признак, что первая строка - это продолжение последней строки прошлой коллекции.
<div class="cmd">bool isgamecmd()</div> - в строке присутствует игровая команда.
<div class="cmd">bool isprompt()</div> - это prompt-строка.
<div class="cmd">string getprompt()</div> - содежимое prompt-строки (без игровых команд).
<div class="cmd">string gettext()</div> - полный текст строки (без учета расцветок отдельных частей).
<div class="cmd">int  gettextlen()</div> - длина полного текста строки.
<div class="cmd">string gethash()</div> - хэш строки. Используется для быстрого сравнения строк.
<div class="cmd">int  blocks()</div> - количество блоков в текущей строке.
<div class="cmd">uint get(int index, string attr)</div> - получает значение атрибута блока. Возможные варианты атрибута: 
<div class="m">textcolor</div>,<div class="m">bkgcolor</div>,<div class="m">underline</div>,<div class="m">italic</div>,<div class="m">blink</div>,<div class="m">reverse</div>,<div class="m">exttextcolor</div>,<div class="m">extbkgcolor</div>.
<div class="cmd">bool set(int index, string attr, uint value)</div> - задает значение атрибута блока. Возможные варианты атрибута см. в <div class="m">get</div>.
<div class="cmd">string getblocktext(int index)</div> - текст блока по заданному индексу.
<div class="cmd">bool setblocktext(int index, string text)</div> - задает новый текст блоку по индексу.
<div class="cmd">bool copyblock(int block, int dst_string, int dst_block)</div> - копирует заданный блок текущей строки в другую строку.
<div class="cmd">bool deleteblock(int index)</div> - удаляет блок.
<div class="cmd">bool deleteallblocks()</div> - удаляет все блоки, остается пустая строка.
<div class="cmd">bool createstring()</div> - создает новую пустую строку. Строка добавляется между текущей строкой и следующей за ней.
<div class="cmd">bool deletestring()</div> - удаляет строку.
</pre>
<hr>
<a name="strings"></a>
<h2>Cтроки, ньюансы работы в Lua</h2>

В клиенте используется кодировка UTF8 для файлов на языке Lua, соответственно вся работа со строками в Lua идет в этой же кодировке. В текущей реализации Lua 5.2, которая 
используется в клиенте, нет нативной поддержки UTF8. Соответственно есть определенные ньюансы работы.<br><br>
- В клиенте не используется официальная библиотека <div class="m">strings</div>, для работы со строками, т.к. она не расчитана на работу с UTF8.<br>
- Операторы <div class="m">==</div>, <div class="m">~=</div>, <div class="m">&lt;</div>, <div class="m">&gt;</div> для сравнения строк можно использовать, 
так как сравнение идет побайтно, а UTF8 обладает свойством, что для нее прекрасно работают операторы сравнения обычных строк.<br>
- Оператор <div class="m">#</div> - длина строки будет работать неправильно, так как он будет возвращать длину строки в байтах, а не в символах.<br><br>
Примечание: К сожалению Lua не позволяет переопределить стандартные операторы для строки, поэтому для оператора <div class="m">#</div> не получилось сделать его 
правильную реализацию. Возможно решение этой проблемы будет найдено позднее.<br><br>

<h4>string</h4>
Для работы со строками, были написаны свои функции:<br>
<div class="m">Внимание!</div> Все индексы символов строки начинаются с 1, а не с 0, так как это принято в языке Lua.<br>
<pre>
<div class="cmd">int len()</div> - длина строки в символах. Данную функцию нужно использовать вместо оператора <div class="m">#</div>.
Пример:
<div class="ee">local s = "Мад отличная игра"
local l = s:len() -- l = 17
</div>
<div class="cmd">string substr(int len)</div> - возвращает подстроку (часть исходной строки) длиной в <div class="m">len</div> первых символов.
<div class="cmd">string substr(int from, int len)</div> - возвращает подстроку(часть исходной строки),
начиная с символа <div class="m">from</div> и длиной <div class="m">len</div> символов. <div class="m">from</div> начинается с 1 (первый символ).
Пример:
<div class="ee">local s = "Мад отличная игра"
local s1 = s:substr(3) -- s1 = "Мад"
local s2 = s:substr(5, 8) -- s2 = "отличная"
</div>
</pre>

<hr>
<a name="decoda"></a>
<h2>Decoda</h2>
<div class="m">Decoda</div> - является средой разработки для языка Lua. Она очень хорошо интегрируется и работает вместе с мад-клиентом. Она позволяет писать и отлаживать 
Lua-скрипты как отдельно, так и параллельно с Visual Studio. Decoda входит в SDK.<br><br>
Для работы с Decoda ее нужно настроить, для этого в окне <div class="m">Project\Settings</div> нужно выставить правильно настройки:
<ul>
<li><div class="m">Command</div> - это полный путь к exe мад клиента.</li> 
<li><div class="m">Command Arguments</div> - пустое поле.</li> 
<li><div class="m">Working Diectory</div> - полный путь к папке, где находится мад-клиент.</li> 
<li><div class="m">Symbols Directory</div> - пустое поле.</li>
</ul>
После этого можно загружать в Decoda lua-файлы и отлаживать их. Decoda будет запускать для этого мад-клиент. Главное, чтобы клиент загружал те же файлы, 
которые отслеживаются Decoda.<br>
Комбинации клавиш в Decoda подобны комбинации в Visual Studio, что достаточно удобно.<br><br>
Нудобством Decoda является то, что она не поддерживает файлы в кодировке UTF8. В этих строках пишутся иероглифы. Планируется исправить этот 
недочет и выпустить новую версию Decoda.
<hr>
<br><br><br>
</body></html>
