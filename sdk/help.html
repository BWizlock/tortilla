<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf8">
<meta http-equiv="content-language" content="ru">
<title>Tortilla мад клиент</title>
<style type="text/css">
body{ background-color: #202020; color: #ffffff; font-size: 16px; font-family: consolas, tahoma; }
h1 { font-size: 40px; color: RGB(210,121,32); align: center; }
h2 { font-size: 28px; color: #1e9da8; }
h3 { font-size: 18px; color: #1e9da8; margin-bottom: 4px; }
h4 { font-size: 18px; color: yellow; margin-bottom: 2px; }
.t { color: #20c020; display: inline; }
.m { color: #20c020; display: inline; }
.e { color: #2080c0; display: inline; }
.ee { color: #909090; border-width: 1px; border-style: solid; width: 100% }
.cmd { color: yellow; display: inline; }
.leftimg { float:left; margin: 7px 7px 7px 0; }
.rightimg  { float: right; margin: 7px 0 7px 7px; }
a.content { color: #20c020; }
hr { border: 1px dashed; color: #909090; }
</style>
</head>
<body link="#3366cc" alink="#ff0000" vlink="#3366cc">
<a name="top"></a>
<center><h1>Tortilla SDK<br></h1></center>

<h2>Содержание</h2>
<ul>
<li><a href="#description">Описание, состав SDK</a></li>
<li><a href="#modules">Модули</a></li>
<li><a href="#plugins">Плагины</a></li>
<li><a href="#devcpp">Разработка на С,С++</a></li>
<li><a href="#devlua">Разработка на Lua</a></li>
<li><a href="#pluginsapi">Функции взаимодействия клиента с плагином, API плагина</a></li>
<li><a href="#clientapi">Функции взаимодействия плагина с клиентом, API клиента</a></li>
<li><a href="#strings">Cтроки, ньюансы работы в Lua</a></li>
<li><a href="#decoda">Decoda</a></li>
</ul>

<h2>Введение</h2>
Tortilla - это клиент для игры в текстовые многопользовательские онлайновые игры MUD (multi users dangeons, dimension or domains games).<br>
Предварительно следует ознакомиться с самой программой на <a href="https://github.com/tmud/tortilla" target="_blank">Сайте программы</a>. Данная информация предназначена для разработчиков под данный клиент.<br><br>
Разработка с помощью SDK предполагает испльзование языков программирования: <div class="m">C</div>, <div class="m">C++</div>, <div class="m">Lua 5.2</div>.<br><br>
Если вы не знаете <div class="m">Lua</div>, то его можно быстро выучить, благодаря этой статье <a href="http://tylerneylon.com/a/learn-lua/" target="_blank">Lua за 15 минут</a>. В данной 
статье собраны все основные правила данного языка, без лишней информации. Этих знаний будет вполне достаточно, чтобы научиться писать плагины и модули для клиента. Если будет желание 
изучить язык <div class="m">Lua</div> получше, то очень советую книгу <div class="m">Programming in Lua, 3rd Edition, Roberto Ierusalimschy</div>.
Дополнительно много информации и статей по данному языку, не считая официальную документацию <a href="http://lua.org" target="_blank">http://lua.org</a>, можно найти в интернете. 
Следует обратить внимание, что в клиенте используется <div class="m">Lua 5.2</div>.

<a name="description"></a>
<h2>Описание, состав SDK</h2>
Данный пакет SDK с набором компонентов предназначен для разработки плагинов и модулей для мад-клиента Tortilla.<br>
Он состоит из:
<ul>
<li><div class="m">Справки</div></li>
<li><div class="m">Библиотек и заголовочных файлов для компиляции</div></li>
<li><div class="m">Проектов-шаблонов, готовых для реализации в них нужного функционала</div></li>
<li><div class="m">Среды разработки для языка Lua - Decoda</div></li>
</ul>
Библиотеки и заголовочные файлы, а также проекты-шаблоны используются для разработки на языке С++. Они расчитаны на использование в <div class="m">Visual Studio 2013</div>.<br>
Если вы будете создавать в плагинах интерфейсные окна, то тогда <div class="m">Express</div> версия <div class="m">Visual Studio</div> скорее всего 
не подойдет, придется использовать <div class="m">Visual Studio 2013 Professional</div> и выше.<br>
Вполне возможна разработка плагинов и модулей на <div class="m">Delphi</div> и других языках, но для этого необходимо провести нужную подготовительную работу - создать или найти необходимые файлы 
для разработки и компиляции для этих языков.<br><br>
Decoda - это среда разработки и отладки на <div class="m">Lua</div>. Она позволяет писать и отлаживать скрипты на <div class="m">Lua</div>, при этом Decoda взаимодействует с мад-клиентом 
в процессе отладки. см. описание <a href="#decoda">Decoda</a>.<br><br>
Модули и плагины можно разрабатывать как на <div class="m">C/C++</div>, так и на <div class="m">Lua</div>. Предполагается, что основным языком разработки 
будет <div class="m">Lua</div>, а <div class="m">C/C++</div> будет больше вспомогательным, на котором будут написаны модули.<br>
Все модули и плагины могут взаимодействовать между собой и с самим клиентом, так как они подключены к общему процессору (виртуальной машине) <div class="m">Lua</div>.<br><br>

Различие между модулями и плагинами только в требованиях. У модулей требований нет, кроме как правил написания их для <div class="m">Lua</div>, а для плагины должны реализовать 
определенный набор функций, см. <a href="#pluginsapi">API для плагинов</a>, чтобы с ними мог работать клиент.

<a name="modules"></a>
<h2>Модули</h2>
Модули - это завершенные программные блоки (библиотеки) для использования в клиенте любым другими модулями или плагинами.<br>
Разрабатывать модули можно на любом языке и в основном это не <div class="m">Lua</div>, так как сам Lua - это расширяемый язык и чтобы на нем чтото сделать, нужно реализовать все основные возможности 
на других языках, а с помощью Lua все собрать в одно целое. В основном модули будут написаны на <div class="m">C/C++</div>, так как это необходимо для расширения возможностей <div class="m">Lua</div> в самом клиенте.
<br><br>
Программно все модули полностью соответствуют требованиям API для библиотек для языка <div class="m">Lua</div>. Поэтому можно использовать готовые Lua-библиотеки 
на просторах интернета. А модули, написанные для клиента, можно использовать в других проектах. Следует обратить внимание, что в клиенте используется <div class="m">Lua 5.2</div>.<br><br>
Все модули располагаются в папке <div class="m">modules</div> клиента. Модули на языке <div class="m">Lua</div> (с расширением <div class="m">*.lua</div>) загружаются автоматически при запуске клиента.<br>
Для загрузки модулей на языке <div class="m">C++</div> и возможно других языках, в виде <div class="m">*.dll</div> файлов, нужно воспользоваться функцией <div class="m">require</div> в Lua-скрипте.<br><br>
Пример:
<div class="ee">[local] module = require "module"</div>
Загружаем модуль с именем module.dll в объект-таблицу module. Имя объекта-таблицы можно использовать и другое! Если будет использовано ключевое слово local, 
то модуль будет доступен только в рамках данного Lua - файла, что рекомендуется делать, так как тогда модуль не будет мешать другим модулям (если в них будут использоваться те же самые имена, без слова local, то возникнет конфликт).
Об этом написано в документации к языку.
<a name="plugins"></a>
<h2>Плагины</h2>
Плагины - это специально написанные для мад-клиента программы, которые расширяют и улучшают возможности самого клиента. Плагины можно разрабатывать на любом языке, но в данном SDK 
присутствует возможность написать их на <div class="m">С</div>, <div class="m">С++</div> и <div class="m">Lua</div>.<br><br>
Файлы плагинов располагаются в папке <div class="m">plugins</div> в каталоге клиента. 
Плагины загружаются только тогда, когда разрешит пользователь. Пользователь управляет загрузкой плагинов в клиенте через специально диалоговое окно настроек (см. программу).

<a name="devcpp"></a>
<h2>Разработка на С и С++</h2>
Для разработки модулей-библиотек и плагинов на языке С++ требуется любая среда разработки на данном языке, например <div class="m">Visual Studio</div>, <div class="m">gcc</div>, <div class="m">Borland</div>. Можно разрабатывать библиотеки и 
на других языках, например <div class="m">Delphi</div>, но для этого нужны файлы для компиляции <div class="m">Lua</div> для данной среды разработки. Их можно найти в интернете. Еще также можно использовать уже готовые <div class="m">Lua</div> библиотеки из интернета.<br><br>
В SDK находяться необходимые для компиляции модулей-библиотек файлы. Данные файлы расчитаны на использование <div class="m">Visual Studio 2013</div> (желательно <div class="m">Professional</div> и выше).<br>
Файлы находятся в папке <div class="m">api</div>. Список файлов:
<ul>
<li><div class="m">base.h</div> - заголовочный файл, который нужно включить с помощью #include, если разрабатывается библиотека-модуль.</li>
<li><div class="m">api.h</div> - заголовочный файл, который нужно включить с помощью #include, если разрабатывается плагин.</li>
<li><div class="m">lua.h lualib.h lauxlib.h</div> - заголовочные файлы из библиотеки lua. Это необходимые вспомогательные файлы, которые подключаются в base.h и api.h</li>
<li><div class="m">api.lib lua.lib</div> - файлы для компиляции(библиотеки). Это также необходимые вспомогательные файлы. Они подключаются в base.h и api.h и дополнительно их подключать не требуется.</li>
</ul>
Разница между <div class="m">base.h</div> и <div class="m">api.h</div> в том, что в первом файле подключается только <div class="m">Lua</div>, а во втором еще дополнительно 
добавлено большое количество функций, которые могут понадобиться для плагинов, так называемое <div class="m">API</div>. Модули по идее не должны использовать <div class="m">API</div> клиента, так как они независимые самостоятельные 
библиотеки, которые можно использовать и в других проектах. Однако использовать <div class="m">API</div> клиента в модулях не запрещено, просто тогда модуль не сможет работать отдельно от 
<div class="m">API</div> в других проектах.<br><br>
Включать в проект нужно либо <div class="m">base.h</div>, либо <div class="m">api.h</div>, но не оба одновременно. Другие файлы включать в проект не нужно.<br>
Библиотеки <div class="m">api.lib, lua.lib</div> расчитаны на статическую линковку Runtime библиотеки в проекте.<br>
Для написания и отладки понадобится и сам клиент, так как он и будет подключать плагин/модуль и работать с ним в процессе разработки.<br><br>
Для написания модуля следует ознакомиться с документацией на язык <div class="m">Lua</div>, однако вкратце связь С++ - Lua работает так:<br>
1. У Lua есть параметр типа <div class="m">lua_State</div>, который является указателем на состояние виртуальной машины и он передается во всех функциях.<br>
2. Передача параметров в функцию Lua, а также получение параметров из функции происходит через стек. Для работы со стеком есть набор функций (см. ниже).<br>
3. Каждая функция <div class="m">Lua</div> на языке <div class="m">С/C++</div> выглядит так:
<pre><div class="ee">int function_name(lua_State *L)
{   ...
    return x;
}
</div></pre>
В качестве параметра выступает указатель на состояние виртуальной машины.<br>
Для работы со стеком, чтобы получить параметры, есть следующие основные функции:<br>
<ul>
<li>int lua_gettop(L) - количество параметров в стеке</li>
<li>int lua_isstring(L, index), lua_isnumber(L, index), ... - проверка на тип значения в стеке по заданному индексу</li>
<li>const char* lua_tostring(L, index), int lua_tointeger(L, index), ... - получение значения из стека по индексу нужного типа</li>
<li>void lua_pushstring(L, const char*), void lua_pushinteger(L, int), ... - затолкнуть в стек параметры</li>
<li>void lua_pop(L, count) - извлечь из стека нужное количество параметров</li>
<li>void lua_settop(L, count) - установить количество параметров на стеке (остальные отбросить, если они были)</li>
<li>void lua_newtable(L) - создает новую таблицу</li>
<li>void lua_settable(L, index) - добавляет значение с вершины стека в таблицу в позиции index</li>
</ul>
В качестве возращаемого значения - количество параметров на вершине стека, которые являются результатом работы функции. То есть функция на вершину 
стека должна поместить результат и вернуть количество параметров в результате. Следует заметить, что можно возвращать из функции сразу несколько значений.<br><br>
Взаимодействие с модулем или плагином происходит через объекты и/или функции, которые регистрирует сам модуль в вирутальной машине <div class="m">Lua</div>. Это 
может либо набор отдельных глобальных функций (м.б. и только одна), либо глобальный объект-таблица или несколько объектов-таблиц.<br>
Модуль должен реализовать функцию:<br>
<pre><div class="ee">int luaopen_xxx(lua_State *L)
{ 
  ...
}
</div></pre><br>
Где 'xxx' имя модуля. Именно эту функцию ищет <div class="m">Lua</div> в dll, чтобы загрузить модуль. И данная функция должна зарегистрировать все необходимые функции и объекты,
чтобы Lua могла работать с модулем.<br>
В SDK есть пример модуля на <div class="m">C++</div> (заготовка-шаблон), где продемонстрированы все основные аспекты написания такого модуля.<br><br>
Плагин должен реализовать точно такую же функцию, только с именем <div class="m">plugin_open</div>, чтобы клиент смог его подключить. Список функций которые должны реализовать плагин 
представлены в разделе <a href="#pluginsapi">API для плагинов</a>. В SDK также есть пример плагина на <div class="m">С++</div>, в котором представлены аспекты уже для плагинов.<br><br>
Следующий аспект, который нужно учесть - это кодировка текстовых строк в плагинах и модулях. Это <div class="m">UTF8 !</div> То есть Lua объекты типа string - это строка 
символов в кодировке UTF8. В SDK это решается за счет макроса который включает поддержку этой кодировки в Visual Studio (данный макрос работает только там). При наличии 
этого макроса все ANSI строки в исходных текстах компилируются как UTF8. В <div class="m">API</div> есть вспомогательные функции для работы с кодировками, см. <a href="#api">функции API</a>.

<a name="devlua"></a>
<h2>Разработка на Lua</h2>
Разработка модулей или плагинов на языке <div class="m">Lua</div> очень проста. Для этого нужно написать код модуля в текстовом файле.<br>
Исходный код модуля будет выглядеть примерно так:<br>
<pre><div class="ee">module = {}
module.var = 0
function module.f1()
...
return result
end

function module.f2()
...
end
...
</div></pre><br>
Это объявление пустой таблицы - с именем модуля. Таблица в <div class="m">Lua</div> является основным элементом в языке и используется в том числе для модулей. Далее идут функции модуля 
и его переменные. И это все! Все что требуется, это написать реализацию модуля. (PS. Синтакис исходного кода модуля не обязательно должен быть похожим на пример. В языке <div class="m">Lua</div> 
довольно широкие вариации написания кода. Читайте документацию к языку.)<br><br>
Однако, чтобы на <div class="m">Lua</div> можно было что-то сделать, базовые возможности уже должны быть реализованы. Это делается за счет других модулей. Если имеющихся возможностей не будет хватать, 
то их придется предварительно реализовать на <div class="m">C/С++</div> или взять готовый модуль из интернета. Модуль использует другой модуль - это принцип, который заложен в данный клиент, и
его нужно использовать. Это дает возможность для быстрого развития самого клиента.<br><br>
Написание плагинов не сложнее, чем написание модулей. Код плагина будет выглядеть примерно так:<br>
<pre><div class="ee">plugin = {}
plugin.var = 0
function plugin.name()
return "Фильтр чата"
end

function plugin.description()
return "Данный плагин позволяет..."
end

function plugin.version()
return "1.0"
end

function plugin.init()
...
end
...
</div></pre>
Для плагинов есть дополнительно набор требований (см. <a href="#pluginsapi">API для плагинов</a>), а в остальном они полностью идентичны модулям.
<br><br>
<div class="t">Правила при написании модулей и плагинов на Lua:</div>
<ul>
<li>Текстовый файл с исходным кодом должен быть в кодировке <div class="m">UTF8</div>. В данном файле должен присутствовать маркер <div class="m">BOM</div> для файлов в UTF8.</li>
<li>Весь код должен быть в рамках объектов-таблиц и функций, которые являются частью этой таблицы:<br>
<pre><div class="ee">module = {} -- объект-таблица модуля
module.var = 0 -- переменная модуля
function module.f1() -- функция модуля
end

a = 10 -- оператор вне функции, так писать крайне не рекомедуется
f(10,20) -- вызов другой функции (не рекомендуется)

local b = 20 -- правильное написание
local t = {...} -- правильное написание
</div></pre></li>
Писать код вне функций не рекомендуется, так как этот код запускается в момент загрузки файла с исходным кодом в Lua - процессор (виртуальную машину). 
Последовательность загрузки модулей в клиенте может быть абсолютно любой, поэтому нет никаких гарантий, что в момент выполнения такого кода, все необходимые модули уже будут загружены. 
Для переменных вне функций следует использовать ключевое слово local, чтобы их ограничить рамками файла (иначе они будут глобальными для всей Lua-машины и возникнет вероятность конфликта 
между модулями и плагинами). Тоже самое относится к вспомогательным таблицам модуля (используйте local).
<li>Название файла с исходным текстом модуля или плагина должно совпадать с названием самого модуля или плагина, чтобы не было путаницы в файлах.</li>
</ul>

<a name="pluginsapi"></a>
<h2>Функции взаимодействия клиента с плагином, API плагина</h2>
В данном разделе представлены все функции, которые должны/могут быть реализованы на стороне плагина. Данные функции вызывает клиент. Когда эти функции будут вызваны описаны в самих функциях.<br>

<h3>Приоритетные функции</h3>
В работе плагинов есть понятие <div class="m">приоритета</div> и <div class="m">приоритетные функции</div>. Данные функции вызываются в том порядке, в котором указаны плагины в клиенте (см. программу). 
Эти функции используются при обработке данных мада в плагине и данные поступают от одного плагина к другому по цепочке(по приоритету), которую указал игрок в настройках. Это нужно учитывать 
при подключении плагинов.
<br><br>
<h3>Обзязательные функции плагина</h3>
Эти функции обязательны для плагина (без них клиент не будет работать с плагином):
<hr>
<h4>string name()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: строка<br></div><br>
Функция должна возвратить название плагина.
<hr>
<h4>string description()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: строка<br></div><br>
Функция должна возвратить подробное описание плагина  (что он делает и для чего предназначен).
<hr>
<h4>string version()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: строка<br></div><br>
Функция должна возвратить версию плагина.
<hr>
<h3>Используемые функции плагина</h3>
Эти функции можно использовать при необходимости. Функции будут вызываться, если они реализованы в плагине.
<a name="init"></a>
<h4>void init()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: нет<br></div><br>
Функция вызывается в момент загрузки плагина. Предназначена для того, чтобы плагин настроил все необходимое для своей работы (например добавил пункт меню, см. <a href="#clientapi">API клиента</a>).
<hr>
<a name="release"></a>
<h4>void release()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: нет<br></div><br>
Функция вызывается в момент выгрузки плагина из клиента и памяти компьютера. Предназначена для того, чтобы плагин сохранил все данные и освободил ресурсы. 
Пункты меню и кнопки панели управления удалять не нужно (удаляются автоматически клиентом).
<hr>
<a name="activated"></a>
<h4>void activated()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: нет<br></div><br>
Функция вызывается когда окно клиента становиться активным, т.е. основным окном, с которым работает игрок. Чтобы узнать текущее состояние 
клиента, нужно использовать метод <div class="cmd">props.activated</div>. См. <a href="#props" class="cmd">props</a>.
<hr>
<a name="deactivated"></a>
<h4>void deactivated()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: нет<br></div><br>
Функция вызывается когда окно клиента перестает быть активным, например сворачивается, т.е. игрок теперь работает с другой программой. 
Текущее состояние клиента можно узнать с помощью <div class="cmd">props.activated</div>.
<hr>
<a name="menucmd"></a>
<h4>void menucmd(int id)</h4>
<div class="m">Параметры: id - целочисленное число</div><br>
<div class="m">Результат: нет<br></div><br>
Клиент вызывает данную функцию, когда пользователь выбирает пункт меню или нажимает кнопку на панели управления, которые относятся к плагину.
В качестве id возвращается идентификатор, который использовался при создании пункта меню или кнопки.
<hr>
<a name="closewindow"></a>
<h4>void closewindow(int hwnd)</h4>
<div class="m">Параметры: hwnd - дескриптор окна</div><br>
<div class="m">Результат: нет<br></div><br>
Функция вызывается в момент закрытия окна плагина (если плагин создает окна, по клику на крестике окна плагина). 
В качестве параметра возращается число - дескриптор окна плагина.
<br>См.также: <a href="#createwindow" class="cmd">createWindow</a>
<hr>
<a name="streamdata"></a>
<h4>string streamdata(string stream)</h4>
<div class="e">Приоритетная функция</div><br>
<div class="m">Параметры: stream - строка, входной поток байт</div><br>
<div class="m">Результат: строка - выходной поток байт<br></div><br>
Функция предназначена для работы с потоком байт, который идет от мад сервера. В метод попадают данные так, как они приходят от мад сервера без 
предварительной обработки. Единственное, что делает клиент - работает со сжатием mccp(если включено), обрабатывает IAC TELNET опции, преобразует данные из 
кодировки сервера в кодировку UTF8. После этого данные попадают в этот метод.<br><br>
Функция обязательно должна вернуть строку - выходной поток данных. Если плагину необходимо изменить этот поток байт, то он может это сделать и вернуть 
уже другие данные. Если изменять данные не нужно, то необходимо вернуть строку-параметр с исходным потоком.
<hr>
<a name="barcmd"></a>
<h4>table barcmd(table сmds)</h4>
<div class="e">Приоритетная функция</div><br>
<div class="m">Параметры: cmds - таблица Lua со списком всех команд</div><br>
<div class="m">Результат: таблица - список команд после обработки<br></div><br>
Функция предназначена для работы со всеми командами, которые вводит пользователь в командной строке клиента. Она вызывается сразу же после ввода команды, еще 
до какой-либо обработки со стороны клиента. Клиент передает в функцию таблицу Lua, в которой перечислены все команды из командной строки 
(клиент разбивает строку на отдельные команды, если введено сразу несколько). Функция может изменить список команд. Если функция не меняет что-то в этом 
списке, то она должна вернуть исходную таблицу.
<hr>
<a name="historycmd"></a>
<h4>bool historycmd(string сmd)</h4>
<div class="e">Приоритетная функция</div><br>
<div class="m">Параметры: cmd - команда</div><br>
<div class="m">Результат: true/false<br></div><br>
Функция предназначена для работы с историей команд клиента. Данная функция вызывается для каждой команды, которую вводит пользователь. 
В качестве результата она должна вернуть булевское значение, которое означает <div class="m">false</div> - не записывать команду в историю клиента, <div class="m">true</div> - 
команду нужно записать. Клиент прекращает дальнейший вызов данной функции у плагинов, если возращается <div class="m">false</div>. 
Сюда не попадают команды, при многострочной вставки из буфера обмена. Команда вызывается до команды <a href="#barcmd" class="cmd">#barcmd</a>).
<hr>
<a name="gamecmd"></a>
<h4>table gamecmd(table сmd)</h4>
<div class="e">Приоритетная функция</div><br>
<div class="m">Параметры: cmd - таблица с игровой командой и параметрами</div><br>
<div class="m">Результат: table - игровая команда + параметры, nil - команду отбросить<br></div><br>
Функция предназначена для работы с игровыми командами игрока (которые будут отправлены на мад-сервер). Сюда попадают все игровые команды, которые вводятся игроком или как результат работы триггеров. 
Плагин может, при необходимости изменить команду, или даже ее отбросить. Функция должна вернуть исходную таблицу, если плагин не изменяет команду, или новую версию команды (nil если отбросить).
В функцию попадает только одна команда, уже после всех обработок клиентом и готовая к отправке на сервер. 
В таблице команда находится под индексом 1. С индекса 2 начинаются параметры. Если нужно узнать количество элементов в таблице, можно выполнить операцию #t или lua_len.<br>
Если нужно предварительно обрабатывать команды, которые вводит пользователь, см. <a href="#barcmd" class="cmd">#barcmd</a>

<hr>
<a name="syscmd"></a>
<h4>table syscmd(table сmd)</h4>
<div class="e">Приоритетная функция</div><br>
<div class="m">Параметры: cmd - таблица со системной командой и параметрами</div><br>
<div class="m">Результат: table - системная команда + параметры, nil - команду отбросить<br></div><br>
Функция предназначена для работы с системными командами (команды клиента, которые начинаются с символа #). Сюда попадают все системные команды, которые вводятся игроком или как результат работы триггеров. 
Плагин может, при необходимости изменить команду, или даже ее отбросить. Функция должна вернуть исходную таблицу, если плагин не изменяет команду, или новую версию команды (nil если отбросить). 
Команда попадает в метод без ведущего символа системной команды #. В функцию попадает только одна команда, уже после всех обработок клиентом и готовая к выполнению клиентом. 
В таблице команда находится под индексом 1. С индекса 2 начинаются параметры. Если нужно узнать количество элементов в таблице, можно выполнить операцию #t или lua_len.<br>
Если нужно предварительно обрабатывать команды, которые вводит пользователь, см. <a href="#barcmd" class="cmd">#barcmd</a>

<hr>
<a name="before"></a>
<h4>void before(int view, viewdata data)</h4>
<div class="e">Приоритетная функция</div><br>
<div class="m">Параметры: view - индекс окна, data - объект-массив, со строками</div><br>
<div class="m">Результат: нет<br></div><br>
Функция предназначена для работы с данными, которые приходят от мад-сервера в виде массива строк (клиент уже сформировал набор строк). Метод вызывается ДО (before) вызова обработчиков 
триггиров, подсветок, замен и других элементов. Он может использоватся как фильтр (удалять или заменять строки, менять цвет) или работать без изменения строк. 
В качестве первого параметра - индекс окна, для которого предназначен массив строк ( 0 - это главное окно мад-клиента, 1 и больше - это output окна клиента). 
В качестве второго параметра выступает специальный объект-массив, с помощью которого можно работать с массивом строк.
<br>См.также: <a href="#viewdata" class="cmd">viewdata</a>, <a href="#cppviewdata" class="cmd">viewdata в С++</a>.
<hr>
<a name="after"></a>
<h4>void after(int view, viewdata data)</h4>
<div class="e">Приоритетная функция</div><br>
<div class="m">Параметры: view - индекс окна, data - объект-массив, со строками</div><br>
<div class="m">Результат: нет<br></div><br>
Функция идентична команде <a href="#before" class="cmd">before</a>, только она работает ПОСЛЕ (after) обработчиков триггиров, подсветок, замен и др. элементов. После этого метода 
строки попадают в главное окно мада или output-окно.
<br>См.также: <a href="#viewdata" class="cmd">viewdata</a>, <a href="#cppviewdata" class="cmd">viewdata в С++</a>.
<hr>
<a name="connect"></a>
<h4>void connect()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: нет<br></div><br>
Функция вызывается, когда клиент устанавливает соединение с мадом.
<hr>
<a name="disconnect"></a>
<h4>void disconnect()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: нет<br></div><br>
Функция вызывается, когда клиент теряет соединение с мадом.
<hr>
<a name="msdp"></a>
<h4>void msdp(table data)</h4>
<div class="m">Параметры: data - таблица с данными протокола MSDP.</div><br>
<div class="m">Результат: нет<br></div><br>
Функция вызывается клиентом, когда от сервера получены данные по протоколу MSDP. Данные передаются в виде таблицы Lua 
(в виде ключ-переменная + значение в виде строк). В качестве значений могут быть пустые строки и таблицы. Таблица используется 
в случае, если получены msdp-массив или msdp-таблица. Для msdp-массива используются цифровые индексы 1+, для msdp-таблицы строковые ключи 
со значениями. Сам стандарт протокола можно прочитать тут: <a href="http://tintin.sourceforge.net/msdp/" target="_blank">MSDP</a>.
<hr>
<a name="msdpon"></a>
<h4>void msdpon()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: нет<br></div><br>
Функция вызывается клиентом, когда установлено соединение по протоколу MSDP. После вызова этого метода можно вызывать функции для 
работы с протоколом. Cм. <a href="#luamsdp" class="cmd">lua msdp</a>, <a href="#cppmsdp" class="cmd">luaT_Msdp</a>. Далее все данные будут поступать 
через функцию <a href="#msdp" class="cmd">msdp</a>.
<hr>
<a name="msdpoff"></a>
<h4>void msdpoff()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: нет<br></div><br>
Функция вызывается клиентом, когда соединение по протоколу MSDP закрылось. Тут можно произвести сброс плагина.
См. <a href="#msdpon" class="cmd">msdpon</a>.
<hr>
<a name="clientapi"></a>
<h2>Функции взаимодействия плагина с клиентом, API клиента</h2>
<div class="m">API клиента</div> делиться на 2 части:
<ul>
<li><a href="#cppapi">С++ API</a> - представлена в файле <div class="m">api.h</div>, который входит в состав SDK.</li>
<li><a href="#luaapi">Lua API</a> - интегрирована в виртуальную машину клиента и доступна как из C++, так и Lua.</li>
</ul>
<a name="cppapi"></a>
<h3>API клиента C++</h3>
Все необходимое API для разработки плагинов находится в <div class="m">api.h</div>, его можно открыть и посмотеть подробно. В этом разделе 
представлено описание содержимого данного файла. Другой файл <div class="m">base.h</div> подключает <div class="m">API Lua</div> 
и с этой частью можно познакомиться в документации к языку.<br><br>
В плагинах используется кодировка <div class="m">UTF8</div>, обратите внимание! Это достигается за счет макроса в файле <div class="m">base.h</div>. 
Все ansi-строки в исходных текстах, при наличии макроса, компилируются как UTF8. Данный макрос работает только в Visual Studio.
<hr>
<h4>bool luaT_check(lua_State *L, int n, ...);</h4>
<div class="m">Параметры: n - количество параметров, ... - параметры</div><br>
<div class="m">Результат: true/false<br></div><br>
Функция проверяет состояние стека Lua машины на соответствие параметрам. Нужно указать количество параметров и их типы. Функция 
предназначена для выбора нужной ветки кода в зависимости от параметров в С++ обработчиках вызовов со стороны Lua.
<hr>
<h4>bool luaT_run(lua_State *L, const utf8* func, const utf8* op, ...);</h4>
<div class="m">Параметры: func - название функции для запуска, op - количество и число параметров, ... - параметры</div><br>
<div class="m">Результат: true/false<br></div><br>
Функция запускает Lua-функцию с заданным именем. Следующий параметр определяет количество и число параметров (одна буква - один параметр):
<ul>
<li>d - целое число (int)</li>
<li>s - строка (utf8)</li>
<li>u - беззнаковое целое число (unsigned int)</li>
<li>o - объект или таблица, данный символ может быть только в первой позиции, сам объект/таблицу нужно предварительно поместить в стек через luaT_pushobject. 
Вызов метода идет в ООП режиме, когда в качестве первого параметра передается сам объект (в Lua это вызов функции через двоеточие).</li>
<li>t - таблица, если данный символ в первой позиции, то вызов метода происходит из самой таблицы. Саму таблицу нужно предварительно поместить в стек.</li>
</ul>
Далее, после строки с типом и числом параметров, идут сами параметры.
<hr>
<h4>int luaT_error(lua_State *L, const utf8* error_message);</h4>
<div class="m">Параметры: error_message - сообщение об ошибке</div><br>
<div class="m">Результат: число - значение с числом параметров на стеке, предназначено для передачи в Lua<br></div><br>
Функция предназначена для завершения какой-либо другой функции, в случае ошибки. Сообщение об ошибке передается в клиент, где и отображается.<br>
Пример:
<pre><div class="ee">int f(lua_State *L)
{ ...
  if (error) 
    return luaT_error('Ошибка');
  ...
}
</div></pre>
<hr>
<h4>void luaT_log(lua_State *L, const utf8* log_message);</h4>
<div class="m">Параметры: log_message - сообщение для пользователя</div><br>
<div class="m">Результат: нет<br></div><br>
Функция предназначена для вывода логов в окно клиента. В настройках клиента указывается окно в которое нужно их выводить.
<h3>API клиента Lua</h3>
<hr>
<h4>void* luaT_toobject(lua_State* L, int index);</h4>
<div class="m">Параметры: index - позиция в стеке Lua</div><br>
<div class="m">Результат: указатель на объект<br></div><br>
Функция возвращает указатель на объект по заданному индексу в стеке. Если это не объект, то возвращается NULL.<br>
<hr>
<h4>void luaT_pushobject(lua_State* L, void *object, int type);</h4>
<div class="m">Параметры: object - указатель на объект, type - тип объекта</div><br>
<div class="m">Результат: нет<br></div><br>
Помещает в стек Lua объект (его указатель) заданного типа.
<hr>
<h4>bool luaT_isobject(lua_State* L, int type, int index);</h4>
<div class="m">Параметры: type - тип объекта, index - позиция в стеке</div><br>
<div class="m">Результат: true/false<br></div><br>
Проверяет, что на стеке Lua находится объект заданного типа.
<hr>
<h4>void luaT_showLuaStack(lua_State* L, const char* label);</h4>
<div class="m">Параметры: label - текстовая метка</div><br>
<div class="m">Результат: нет<br></div><br>
Функция предназначена для отладки плагинов. Она через метод Win32API OutputDebugString выводит содержимое стека Lua на момент вызова. 
Эта информация попадает в отладчик C++. Эту информацию можно увидеть и с помощью программы <a href="http://technet.microsoft.com/en-us/sysinternals/bb896647.aspx" target="_blank">DebugView</a>, 
при условии что отладчик не работает (он перехватывает OutputDebugString). Текстовая метка используется для идентификации нужного вызова метода.
<hr>
<h4>void luaT_showTableOnTop(lua_State* L, const char* label);</h4>
<div class="m">Параметры: label - текстовая метка</div><br>
<div class="m">Результат: нет<br></div><br>
Функция предназначена для отладки плагинов. Она через метод Win32API OutputDebugString выводит содержимое таблицы на вершине стека Lua на момент вызова. 
см. <div class="m">luaT_showLuaStack</div>.
<hr>
<a name="luatwindow"></a>
<h4>class luaT_window</h4>
Любой плагин, при необходимости может создавать для себя дополнительные окна. Данный класс предназначен для облегчения решения этой задачи. 
Класс является оберткой вокруг Lua объекта Окно. В Lua есть аналог - <a href="#window" class="cmd">window</a>. 
В дополнительное окно можно подключить свое окно (использовать как контейнер), а можно рисовать (только из Lua-скриптов) с помощью встроенных 
возможностей в клиент (см. <a href="#render" class="cmd">render</a>).
<br>
<pre>
<div class="cmd">bool create(lua_State *pL, const utf8* caption, int width, int height)</div> - создание окна-контейера, с заданными 
размерами и заголовком.
<div class="cmd">HWND hwnd()</div> - получение дескриптора окна.
<div class="cmd">HWND floathwnd()</div> - получение дескриптора самого базового окна с рамкой и заголовком.
<div class="cmd">void hide()</div> - скрыть окно.
<div class="cmd">void show()</div> - показать окно.
<div class="cmd">bool isVisible()</div> - проверка видимо окно или нет.
<div class="cmd">void dock(const utf8* side)</div> - заставляет окно пристыковаться к нужной стороне клиента. 
Возможные варианты: 'left', 'right', 'top', 'bottom'. Допускается перечисление нескольких вариантов через запятую.
<div class="cmd">void undock()</div> - окно открепляется от окна клиента.
<div class="cmd">void block(const utf8* side)</div> - блокировка возможности прикрепить окно к определенной стороне. 
Возможные варианты: 'left', 'right', 'top', 'bottom', 'float'. Вариант 'float' означает, что окно не может быть 
плавающим и всегда должно быть пристыкованным. Допускается перечисление нескольких вариантов через запятую.
<div class="cmd">void attach(HWND child)</div> - подключение своего окна внутрь дополнительного окна. Дополнительное окно выступает 
в качестве контейнера.
</pre>
См. также <a href="#luatpanel" class="cmd">luaT_panel</a>.
<hr>
<a name="luatpanel"></a>
<h4>class luaT_panel</h4>
Панели - это еще один вид окон, кроме дополнительных окон, которые может создавать плагин. Панели - это окна, которые имеют фиксированный размер 
и распологаются на одной из сторон клиента. Панели нельзя перемещать. В Lua есть аналог - <a href="#panel" class="cmd">panel</a>. Панель создается на 
всю высоту или ширину окна клиента (в зависимости от стороны расположения), но с заданной шириной или высотой соответственно.
В дополнительное окно можно подключить свое окно (использовать как контейнер), а можно рисовать (только из Lua-скриптов) с помощью встроенных 
возможностей в клиент (см. <a href="#render" class="cmd">render</a>).
<pre>
<div class="cmd">bool create(lua_State *pL, const utf8* side, int size)</div> - создание панели. Нужно указать сторону, где будет 
располагаться панель и ее размер в пикселях. Вариант значения <div class="cmd">side</div> - 'left', 'right', 'top', 'bottom'.
<div class="cmd">void attach(HWND child)</div> - подключение своего окна внутрь панели. Панель выступает в качестве контейнера.
<div class="cmd">HWND hwnd()</div> - получение дескриптора окна панели.</div>
</pre>
См. также <a href="#luatwindow" class="cmd">luaT_window</a>.
<hr>
<a name="cppviewdata"></a>
<h4>class luaT_ViewData</h4>
Класс предназначен для манипуляции со строками, которые плагин получает от клиента. Используется при работе с методами <a href="#before" class="cmd">before</a> и 
<a href="#after" class="cmd">after</a>. В Lua есть подобный интерфейс <a href="#viewdata" class="cmd">viewdata</a>
<br><div class="m">Внимание!</div> Все индексы начинаются с 1, а не с 0, т.е рабочий диапозон индексов [1..n]. Решение связано с интеграцией с языком Lua.
<pre>
<div class="cmd">void init(lua_State *pL, void *viewdata)</div> - инициализация.
<div class="cmd">int  size()</div> - количество строк.
<div class="cmd">bool select(int index)</div> - выбор строки для дальнейшей работы.
<div class="cmd">int  getIndex()</div> - индекс текущей строки.
<div class="cmd">bool isFirst()</div> - первая строка является продолжением последней строки (завершение предыдущей строки).
<div class="cmd">bool isLast()</div> - последняя строка является завершенной, ее продолжения в следующей коллекции не будет.
<div class="cmd">bool isGameCmd()</div> - в строке присутствует игровая команда.
<div class="cmd">bool isSystem()</div> - это строка с логом клиента.
<div class="cmd">bool isPrompt()</div> - это prompt строка.
<div class="cmd">void getPrompt(u8string *str)</div> - возвращает prompt-строку (без возможных команд в строке).
<div class="cmd">void getText(u8string* str)</div> - полный текст строки (без учета расцветки).
<div class="cmd">int  getTextLen()</div> - длина всей строки в символах (без учета расцветки).
<div class="cmd">void getHash(u8string* str)</div> - хэш сумма строки. Используется для быстрого сравнения строк.
<div class="cmd">int  blocks()</div> - количество отдельных блоков в текущей строке.
<div class="cmd">bool get(int block, int param, unsigned int *value)</div> - значение параметра блока текущей строки. Допустимые значения параметра:
<div class="m">TEXTCOLOR</div>, <div class="m">BKGCOLOR</div>, <div class="m">UNDERLINE</div>, <div class="m">ITALIC</div>, <div class="m">BLINK</div>, <div class="m">REVERSE</div>, <div class="m">EXTTEXTCOLOR</div>, <div class="m">EXTBKGCOLOR</div>.
<div class="cmd">bool set(int block, int param, unsigned int value)</div> - устанавливает значение параметра блока текущей строки.
<div class="cmd">void getBlockText(int block, u8string* str)</div> - текст блока текущей строки.
<div class="cmd">bool setBlockText(int block, const utf8* text)</div> - задает новый текст блоку текущей строки.
<div class="cmd">bool copyBlock(int block, int dst_string, int dst_block)</div> - копирует заданный блок текущей строки в другую строку.
<div class="cmd">bool deleteBlock(int block)</div> - удаляет блок текущей строки.
<div class="cmd">bool deleteAllBlocks()</div> - удаляет все блоки, остается пустая строка.
<div class="cmd">bool createString()</div> - создает новую пустую строку. Строка добавляется между текущей строкой и следующей за ней.
<div class="cmd">bool createString(bool system, bool gamecmd)</div> - новая строка. Параметры задают соответствующие флаги новой строки.
<div class="cmd">bool deleteString()</div> - удаляет текущую строку.
</pre>
<hr>
<a name="cppactobj"></a>
<h4>class luaT_ActiveObjects</h4>
Класс предназначен для манипуляции с объектам клиента. <a href="#luaactobj" class="cmd">Подобная возможность</a> в Lua.<br>
Поддеживаемые типы объектов:
<ul>
<li><div class="m">aliases</div> - макросы</li>
<li><div class="m">actions</div> - триггеры</li>
<li><div class="m">subs</div> - замены</li>
<li><div class="m">antisubs</div> - антизамены</li>
<li><div class="m">highlights</div> - подсветки</li>
<li><div class="m">hotkeys</div> - горячие клавиши</li>
<li><div class="m">gags</div> - фильтры</li>
<li><div class="m">vars</div> - переменные</li>
<li><div class="m">groups</div> - группы</li>
<li><div class="m">timers</div> - таймеры</li>
<li><div class="m">tabs</div> - подстановки</li>
</ul>
<br><div class="m">Внимание!</div> Все индексы начинаются с 1, а не с 0, т.е рабочий диапозон индексов [1..n]. Решение связано с интеграцией с языком Lua.
<pre>
<div class="cmd">luaT_ActiveObjects(lua_State *pL, const char* type)</div> - инициализация (конструктор), возможные типы см. выше.
<div class="cmd">int  size()</div> - количество элементов.
<div class="cmd">bool select(int index)</div> - выбор нужного элемента по индексу.
<div class="cmd">bool add(const utf8* key, const utf8* value, const utf8* group)</div> - добавление нового элемента. Если элемент существует, 
то выходит с ошибкой.
<div class="cmd">bool replace(const utf8* key, const utf8* value, const utf8* group)</div> - заменяет текущий элемент. Если элемент не существует, 
то добавляет новый.
<div class="cmd">bool del()</div> - удаление текущего элемента.
<div class="cmd">int  getIndex()</div> - получение позиции текущего элемента.
<div class="cmd">bool setIndex(int index)</div> - переместить текущий элемент в нужную позицию.
<div class="cmd">bool get(int param, u8string* value)</div> - получить параметр текущего элемента. Возможные варианты параметра:
<div class="m">KEY</div>, <div class="m">VALUE</div>, <div class="m">GROUP</div>.
<div class="cmd">bool set(int param, const utf8* value)</div> - установка нужного параметра у текущего элемента.
<div class="cmd">bool update()</div> - применить все изменения. Только после вызова этого оператора все изменения вступят в силу.
</pre>
<hr>
<a name="cppprops"></a>
<h4>class luaT_Props</h4>
Класс предназначен для получения текущих настроек клиента. в Lua есть такой же набор методов в объекте <a href="#props" class="cmd">props</a>.<br>
Методы класса:
<pre>
<div class="cmd">COLORREF paletteColor(int index)</div> - цвет из палитры клиента. Возможные значения индекса от 0 до 255.
<div class="cmd">COLORREF backgroundColor()</div> - цвет фона всех окон клиента.
<div class="cmd">void cmdPrefix(u8string* str)</div> - получение префикса системной команды клиента.
<div class="cmd">void cmdSeparator(u8string* str)</div> - получение разделителя команд клиента.
<div class="cmd">void serverHost(u8string* str)</div> - адрес сервера, куда подключен клиент (пустая строка, если нет подключения).
<div class="cmd">void serverPort(u8string* str)</div> - адрес порта подключения (пустая строка, если нет подключения).
<div class="cmd">bool connected()</div> - признак, что клиент подключен к маду.
<div class="cmd">HFONT currentFont()</div> - хэндл текущего шрифта клиента.
<div class="cmd">bool activated()</div> - признак, что окно клиента активно и игрок работает с ним.
</pre>
<hr>
<a name="cppmsdp"></a>
<h4>class luaT_Msdp</h4>
Класс предназначен для работы с протоколом MSDP. Методы класса отправляют серверу управялющие команды протокола. Данные поступают через 
метод <a href="#msdp" class="cmd">msdp</a> плагина. Стандарт протокола можно прочитать тут: <a href="http://tintin.sourceforge.net/msdp/" target="_blank">MSDP</a>.
<pre>
<div class="cmd">void list(const u8string&amp; listname)</div> - получение списка переменных заданной категории(списка).
<div class="cmd">void send(const std::vector&lt;u8string&gt;&amp; vars)</div> - однократное получение текущих значений переменных.
<div class="cmd">void reset(const std::vector&lt;u8string&gt;&amp; vars)</div> - сброс переменных в исходное состояние.
<div class="cmd">void report(const std::vector&lt;u8string&gt;&amp; vars)</div> - подписка на оповещение об изменении переменных.
<div class="cmd">void unreport(const std::vector&lt;u8string&gt;&amp; vars)</div> - отписка от оповещения.
</pre>
См. также <a href="#luamsdp" class="cmd">msdp</a>.
<hr>
<h4>Преобразование кодировок</h4>
В <div class="m">API</div> клиента есть методы для переобразования текста между различными кодировками.<br>
Для преобразования существуют специальные классы-обертки:
<pre>
<div class="cmd">const wchar_t* TU2W(const utf8* string)</div> - конвертация строки из UTF8 в UTF16
<div class="cmd">const utf8* TW2U(const wchar_t* string)</div> - конвертация строки из UTF16 в UTF8
<div class="cmd">const wchar_t* TA2W(const char* string)</div> - конвертация строки из ANSI в UTF16
<div class="cmd">const char* TW2A(const wchar_t* string)</div> - конвертация строки из UTF16 в ANSI

Объекты TU2W, TW2U, TA2W и TW2A - выполнены в виде классов, которые рассчитаны на использование в стиле функции:
<div class="ee">...
u8string x( TW2U(L"строка") );
...
</div>
Необходимость класса - удаление временного буфера для строки-результата конвертации.
</pre>
<hr>
<h4>Работа с XML</h4>
В <div class="m">API</div> клиента есть возможность работать с <div class="m">XML</div>.<br>

<h4>class xml::node</h4>
Класс представляет собой обертку вокруг методов работы с вершиной <div class="m">XML</div> документа.
<pre>
<div class="cmd">node(const utf8* rootnode)</div> - создание нового документа с заданным именем корнего узла
<div class="cmd">node(xnode xml_node)</div> - подключение обертки к вершине
<div class="cmd">bool load(const utf8 *filename)</div> - загрузка в вершину xml-файла
<div class="cmd">bool save(const utf8 *filename)</div> - запись вершины в xml-файл
<div class="cmd">void deletenode()</div> - удалить вершину.
<div class="cmd">void getname(u8string *name)</div> - имя вершины.
<div class="cmd">bool get(const utf8* attribute, u8string* value)</div> - атрибут вершины.
<div class="cmd">bool get(const utf8* attribute, int* value)</div> - атрибут вершины в виде числа.
<div class="cmd">bool get(const utf8* attribute, std::wstring* value)</div> - атрибут вершины в виде строки UTF16.
<div class="cmd">void set(const utf8* attribute, const utf8* value)</div> - задать атрибут.
<div class="cmd">void set(const utf8* attribute, int value)</div> - задать атрибут в виде числа.
<div class="cmd">void set(const utf8* attribute, const std::wstring& value)</div> - задать атрибут в виде строки UTF16.
<div class="cmd">void gettext(u8string *text)</div> - текст вершины.
<div class="cmd">void settext(const utf8* text)</div> - задать текст вершины.
<div class="cmd">xml::node createsubnode(const utf8* name)</div> - создать дочернюю вершину.
<div class="cmd">int  size()</div> - количество атрибутов у вершины.
<div class="cmd">bool getattrname(int index, u8string* value)</div> - имя атрибута по индексу.
<div class="cmd">bool getattrvalue(int index, u8string* value)</div> - значение атрибута по индексу.
<div class="cmd">bool move(const utf8* path)</div> - переместить вершину в другую позицию по заданному пути.
<div class="cmd">bool create(const utf8* path)</div> - создать вершину по заданному пути.
</pre>
<h4>class xml::request</h4>
Класс позволяет делать выборку нужных вершин по выражению. Похоже на запрос к базе данных.
<pre>
<div class="cmd">request(xnode node, const utf8 *request_string)</div> - выбрать нужные дочерние вершины у текущей вершины по выражению.
<div class="cmd">request(xml::node& node, const utf8 *request_string)</div> - выбрать нужные дочерние вершины у текущей вершины по выражению.
<div class="cmd">int  size()</div> - количество вершин в выборке.
<div class="cmd">bool empty()</div> - проверка, что выборка пустая.
<div class="cmd">xml::node operator[](int node_index)</div> - получить вершину выборки по индексу.
</pre>
<hr>
<a name="pcrecpp"></a>
<h4>Работа с регулярными выражениями</h4>
В <div class="m">API</div> клиента есть методы работы с текстами посредством регулярных выражений. Используется <a href="http://www.pcre.ru/" target="_blank">PCRE</a> диалект.<br>
В Lua также есть поддержка Pcre (см. <a href="#pcre" class="cmd">pcre</a>).
<h4>class Pcre</h4>
В регулярных выражениях круглые скобки <div class="m">'()'</div> имеют особый смысл. Они используются для выделения интересующей части искомой строки.<br>
Методы <div class="cmd">first</div>, <div class="cmd">last</div>, <div class="cmd">size</div> используются для работы с такими скобками. См. документацию 
по PCRE.
<pre>
<div class="cmd">bool init(const utf8* _rgxp)</div> - инициализация регулярным выражением.
<div class="cmd">bool find(const utf8* string)</div> - поиск в строке по регулярному выражению.
<div class="cmd">bool findall(const utf8* string)</div> - поиск всех подстрок в строке по регулярному выражению.
<div class="cmd">int  size()</div> - количество найденных параметров в круглых скобках + 1 (совпадение по всему регулярному выражению). 
<div class="m">Замечание:</div> Если поиск производился методом <div class="cmd">find</div>, то по индексу <div class="m">0</div> будут получены границы совпадения 
всего регулярного выражения, а с индекса <div class="m">1</div> начнутся совпадения для круглых скобок <div class="m">'()'</div>. Если поиск производился 
методом <div class="cmd">findall</div>, то по индексу <div class="m">0</div> будут границы всех совпадений (начало первого совпадения и конец последнего), 
а с индекса <div class="m">1</div> начнутся отдельные совпадения подстрок.
<div class="cmd">int  first(int index)</div> - начальная позиция в строке (индекс символа) по индексу параметра, с которого начинается 
совпадение по регулярному выражению.
<div class="cmd">int  last(int index)</div> - конечная позиция в строке (индекс символа+1), на котором заканчивается совпадение 
по регулярному выражению.
<div class="cmd">void getstring(int index, u8string *str)</div> - получить строку, которая находится в границах по заданному индексу.
</pre>
<hr>
<a name="luaapi"></a>
<h3>API клиента Lua</h3>
В данно разделе представлен набор функций, которые встроены в виртуальную машину Lua клиента.<br>
Подключены следующие функции и модули из стандартных библиотек <div class="m">Lua</div>:
<ul>
<li>Все стандартные методы Lua, функции: <div class="m">assert</div>, <div class="m">type</div>, <div class="m">tonumber</div>, <div class="m">tostring</div> и другие (см. документацию к <div class="m">Lua</div>).</li>
<li>Методы по работе таблицами: <div class="m">table.sort</div>, <div class="m">table.insert</div>, <div class="m">table.remove</div>, <div class="m">table.concat</div>, и др.</li>
<li>Математические методы: <div class="m">math.floor</div>, <div class="m">math.ceil</div>, <div class="m">math.random</div>, <div class="m">math.min</div>, <div class="m">math.max</div> и др.</li>
</ul>
Также подключены и функции <div class="m">API</div>. Данные методы доступны и из <div class="m">С++</div> кода с помощью метода <div class="cmd">luaT_run</div>. Если 
понять механизм взаимосвязи C++ - Lua, то можно вызывать любые функции Lua из кода С++.
<hr>
<h4>void addCommand(string cmd)</h4>
<div class="m">Параметры: cmd - системная команда</div><br>
<div class="m">Результат: нет<br></div><br>
Функция добавляет в клиент новую системную команду (через '#'). Данная команда будет участвовать в автоподстановках.
Через метод <a href="#syscmd" class="cmd">syscmd</a> плагин может реализовать функционал команды. Данная функция расчитана на 
использовании в методе <a href="#init" class="cmd">init</a>. Системная команда автоматически удаляется, в момент выгрузки плагина.
<hr>
<h4>void runCommand(string cmd)</h4>
<div class="m">Параметры: cmd - игровая или системная команда</div><br>
<div class="m">Результат: нет<br></div><br>
Функция выполняет команду (или набор команд), если бы ее ввел человек. Для получения символов перфикса системной команды и разделителя, используйте 
команды <div class="cmd">props.cmdPrefix</div> и <div class="cmd">props.cmdSeparator()</div>. См. <a href="#props" class="cmd">props</a>
<hr>
<h4>void addMenu(string path, int id, int pos)</h4>
<div class="m">Параметры: path - путь, id - идентификатор, pos - позиция</div><br>
<div class="m">Результат: нет<br></div><br>
Функция добавляет в меню клиента новый пункт меню. Параметр path определяет метоположение пункта меню. Последнее слова в пути - это название пунка меню. 
id - идентификатор, который будет передан в функцию <a href="#menucmd" class="cmd">menucmd</a>, pos - местоположение пункта меню относительно других. 
Пункт меню автоматически удаляется при выгрузке плагина, функция расчитана на использование в методе <a href="#init" class="cmd">init</a>.<br>
Пример:
<pre><div class="ee">function plugin.init()
...
addMenu('Справочник/База предметов', 100, 1)
...
end
</div></pre>
Пример создаст пункт меню: 'Справочник' в главном меню, 'База предметов' - пункт в этом меню, идентификатор пункта 100, пункт 'Справочник' - будет на 
первой позиции в главном меню.
<hr>
<h4>void addButton(int bmp, int id, string tooltip)</h4>
<div class="m">Параметры: bmp - идентификатор картинки, id - идентификатор команды, tooltip - подсказка</div><br>
<div class="m">Результат: нет<br></div><br>
Функция добавляет кнопку на панель инструментов клиента. Картинка загружается из ресурсов плагина. 
id - идентификатор, который будет передан в функцию <a href="#menucmd" class="cmd">menucmd</a>, tooltip - всплывающая подсказка, при наведении стрелки 
мыши на кнопку. Кнопка автоматически удаляется при выгрузке плагина, функция расчитана на использование в методе <a href="#init" class="cmd">init</a>. 
Картинка должна быть в формате <div class="m">BMP</div>.
<br>
<div class="m">Замечание:</div> загрузка картинки для Lua плагина (из файла) пока не реализована.
<hr>
<h4>void addToolbar(string name [,int buttons_size])</h4>
<div class="m">Параметры: name - название, buttons_size - размер кнопок (необязательный параметр)</div><br>
<div class="m">Результат: нет<br></div><br>
Функция создает новую панель инструментов (тулбар) с заданным именем. Дополнительно можно указать размер картинок, которые будут использоваться 
в кнопках на данном тулбаре. После создания, все последующие вызовы метода <div class="cmd">addButton</div> будут добавлять кнопки на данный тулбар. 
Тулбар автоматически удаляется при выгрузке плагина, функция расчитана на использование в методе <a href="#init" class="cmd">init</a>. 
<hr>
<h4>void hideToolbar(string name)</h4>
<div class="m">Параметры: name - название</div><br>
<div class="m">Результат: нет<br></div><br>
Функция скрывает панель инструментов (тулбар) с заданным именем.
<hr>
<h4>void showToolbar(string name)</h4>
<div class="m">Параметры: name - название</div><br>
<div class="m">Результат: нет<br></div><br>
Функция включает отображение панели инструментов (тулбар) с заданным именем.
<hr>
<h4>void checkMenu(int id)</h4>
<div class="m">Параметры: id - идентификатор</div><br>
<div class="m">Результат: нет<br></div><br>
Функция переводит пункт меню или кнопки в состояние checked. Нужно передать идентификатор пункта меню или кнопки.
<hr>
<h4>void uncheckMenu(int id)</h4>
<div class="m">Параметры: id - идентификатор</div><br>
<div class="m">Результат: нет<br></div><br>
Функция снимает с пункта меню или кнопки состояние checked. Нужно передать идентификатор пункта меню или кнопки.
<hr>
<h4>void enableMenu(int id)</h4>
<div class="m">Параметры: id - идентификатор</div><br>
<div class="m">Результат: нет<br></div><br>
Функция переводит пункт меню или кнопку в состояние активно. Нужно передать идентификатор пункта меню или кнопки.
<hr>
<h4>void disableMenu(int id)</h4>
<div class="m">Параметры: id - идентификатор</div><br>
<div class="m">Результат: нет<br></div><br>
Функция блокирует пункт меню или кнопку (состояние заблокировано). Нужно передать идентификатор пункта меню или кнопки.
<hr>
<h4>string getPath(string file)</h4>
<div class="m">Параметры: file - относительный путь к файлу</div><br>
<div class="m">Результат: полный путь к файлу<br></div><br>
Функция расчитывает полный путь к файлу по его относительному пути.<br>
Функция использует текущее имя группы профилей (мир), чтобы плагин мог работать с разными профилями.
<hr>
<h4>string getProfile()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: имя текущего профиля (персонажа)<br></div><br>
Функция возвращает имя текущего профиля (персонажа).<br>
Пример получения полного пути к файлу, в зависимости от группы профилей(мир) и имени текущего профиля(персонаж):
<pre><div class="ee">local path = getPath(getProfile()..".xml")
</div></pre>
<hr>
<h4>HWND getParent()</h4>
<div class="m">Параметры: нет</div><br>
<div class="m">Результат: хэндл окна клиента<br></div><br>
Функция возвращает идентификатор - хэндл окна мад клиента в Windows. Используется для работы с окнами в плагинах с интерфейсом.
<hr>
<h4>void saveTable(table t, string file)</h4>
<div class="m">Параметры: t - таблица для сохранения, file - имя файла</div><br>
<div class="m">Результат: нет<br></div><br>
Функция сохраняет заданную таблицу в файл. Данные сохраняются в виде xml. Поддерживаются только числа и строки, в качестве параметров таблицы. 
Допускается вложенность таблиц. Путь к файлу вычисляется, в зависимости от имени группы профилей (мир) и имени плагина. 
Функция предназначена для сохранения настроек плагина для каждого мира и персонажа в отдельности.
Пример сохранения настроек (таблица Lua) в файле, с учетом имени профиля(персонажа):
<pre><div class="ee">saveTable( {...}, getProfile()..".xml")</pre>
Клиент создаст файл по заданному пути: <div class="cmd">gamedata/имя группы профилей(мир)/имя плагина/имя профиля(персонажа).xml</div> 
и сохранит в него данные из таблицы. Неподдерживаемые типы параметров пропускаются.
<hr>
<h4>table loadTable(string file)</h4>
<div class="m">Параметры: file - имя файла</div><br>
<div class="m">Результат: table - таблица<br></div><br>
Функция загружает таблицу из файла. Поддерживаются только числа и строки. Путь к файлу вычисляется, в зависимости от имени 
группы профилей (мир) и имени плагина (аналогично <div class="cmd">saveTable</div>). Функция предназначена для загрузки настроек плагина с 
учетом группы профилей, имени плагина и имени персонажа(при необходимости).
Пример загрузки настроек (таблица Lua) из файла, с учетом имени профиля(персонажа):
<pre><div class="ee">local t = loadTable(getProfile()..".xml")</pre>
<hr>
<a name="createwindow"></a>
<h4>window createWindow(string title, [int width, int height])</h4>
<div class="m">Параметры: title - заголовок окна, width,height - ширина и высота окна</div><br>
<div class="m">Результат: объект окно (window)<br></div><br>
Функция создает дополнительное окно (для отображения любой информации) - <a href="#window" class="cmd">window</a>. В качестве 
параметров - заголовок окна и размеры окна (ширина и высота).
<hr>
<a name="createpanel"></a>
<h4>panel createPanel(string side, int size)</h4>
<div class="m">Параметры: side - сторона, где нужно создать панель. size - размер панели в пикселях.</div><br>
<div class="m">Результат: объект панель (panel)<br></div><br>
Функция создает панель (для отображения любой информации) - <a href="#panel" class="cmd">panel</a>. В качестве 
параметров - сторона (возможные варианты: 'left', 'right', 'top', 'bottom') и размер в пикселях.
<hr>
<a name="createpcre"></a>
<h4>pcre createPcre(string regexp)</h4>
<div class="m">Параметры: string - строка с регулярным выражением.</div><br>
<div class="m">Результат: объект регулярки (pcre)<br></div><br>
Создает регулярное выражение <a href="#pcre" class="cmd">pcre</a> по строке. Возвращает <div class="m">nil</div>, если указана некорректная строка.
<hr>
<h4>void log(string message [,string messsage2, ...])</h4>
<div class="m">Параметры: message, message2 и т.д. - текст сообщения</div><br>
<div class="m">Результат: нет<br></div><br>
Функция предназначена для вывода строки в окно клиента в качестве логов. Окно для вывода строки указывается в настройках клиента.
Функция поддерживает любое количество параметров (в этом случае они соединяются в одну общую строку). 
Поддерживаются числа, строки, булевые выражения.
<hr>
<h4>void terminate([string message [,string messsage2, ...]])</h4>
<div class="m">Параметры: message и т.д. - текст сообщения. Необязательный параметр.</div><br>
<div class="m">Результат: нет<br></div><br>
Функция выводит строки логов в окно клиента и выключает плагин. Используется для выключения плагином самого себя, в случае, 
если он не может продолжать работу по какой-либо причине. Текст ошибки передается, как параметр.
Функция поддерживает любое количество параметров (в этом случае они соединяются в одну общую строку). 
Поддерживаются числа, строки, булевые выражения. Окно для вывода указывается в настройках клиента.
<hr>
<a name="window"></a>
<h4>window</h4>
Дополнительное окно создается с помощью функции <a href="#createwindow" class="cmd">createWindow</a>. Lua объект <div class="cmd">window</div> является тем же интерфейсом, 
что и <a href="#luatwindow" class="cmd">luaT_window</a> на стороне С++. Дополнительные окна - плавающие окна, с возможностью пристыковаться 
к границе главного окна клиента.
<pre>
<div class="cmd">void dock(string side)</div> - заставляет окно пристыковаться к нужной стороне клиента. 
Возможные варианты: 'left', 'right', 'top', 'bottom'. Допускается перечисление нескольких вариантов через запятую.
<div class="cmd">void undock()</div> - окно открепляется от окна клиента.
<div class="cmd">void block(string side)</div> - блокировка возможности прикрепить окно к определенной стороне.
Возможные варианты: 'left', 'right', 'top', 'bottom', 'float'. Вариант 'float' означает, что окно не может быть 
плавающим и всегда должно быть пристыкованным. Допускается перечисление нескольких вариантов через запятую.
<div class="cmd">void show()</div> - отображает окно.
<div class="cmd">void hide()</div> - скрывает окно.
<div class="cmd">bool isVisible()</div> - возвращает статус видимо окно или нет.
<div class="cmd">render setRender(function f)</div> - возвращает объект, с помощью которого можно будет рисовать. Не работает, если окно используется 
как контейнер. В качестве параметра выступает функция, которая будет вызываться клиентом в момент перерисовки окна. 
В ней следует использовать объект render, который был получен в данной функции. см. <a href="#render" class="cmd">render</a>.
</pre>
<hr>
<a name="panel"></a>
<h4>panel</h4>
Панели - окна, именющие фиксированный размер, располагаются на одной из сторон клиента, без возможности перемещения. см. <a href="#luatpanel" class="cmd">luaT_panel</a>. 
Панели в Lua создаются с помощью функции  <a href="#createpanel" class="cmd">createPanel</a>. 
<pre><!-- <div class="cmd">void attach(HWND child)</div> - подключение своего окна в панель-контейнер. -->
<div class="cmd">render setRender(function f)</div> - возвращает объект, с помощью которого можно будет рисовать. Не работает, если окно используется 
как контейнер. В качестве параметра выступает функция, которая будет вызываться клиентом в момент перерисовки окна. 
В ней следует использовать объект render, который был получен в данной функции. см. <a href="#render" class="cmd">render</a>.
</pre>
<hr>
<a name="render"></a>
<h4>render</h4>
В дополнительных окнах и панелях клиента можно рисовать с помощью встроенных возможностей в клиент. Рисовать можно только с 
помощью Lua-скриптов, так как для C++ варианта доступно все окно и тут можно делать любые действия, а в Lua возможности 
ограничены клиентом. Данная возможность сделана для быстрой разработки на Lua плагинов-виджетов, необходимых для игры.<br><br>
<div class="m">Важно!</div> Не вызвайте напрямую функцию рисования (которая была установлена через 
<div class="cmd">window:setRender</div> или <div class="cmd">panel:setRender</div>). Если необходимо перерисовать окно, то 
нужно использовать <div class="cmd">render:update()</div>.
<pre>
<div class="cmd">void setBackground(color)</div> - Установка цвета фона окна.<br>
<a name="color"></a>
Возможные варианты определения цвета <div class="m">color</div>:
<ul>- r, g, b - цвет через три числа - компонеты отдельного цвета.
- color - цвет через одно общее число
- { r=10,g=20,b=30 } - цвет как таблица с указанием значений отдельных компонентов цвета.
</ul>Примеры:<div class="ee">render:setBackground(10, 20, 30)
render:setBackground(10203)
render:setBackground{ r=10,g=20,b=30 }
</div>

<div class="cmd">void textColor(color)</div> - цвет текста (см. <a class="cmd" href="#color">color</a>).
<div class="cmd">int width()</div> - ширина окна.
<div class="cmd">int height()</div> - высота окна.

<div class="cmd">pen createPen(table params)</div> - создание пера.
Параметры для создания пера <div class="m">pen</div>:
<ul>- <div class="m">style</div> - стиль пера. Возможные варианты: <div class="m">solid</div> (по умолчанию), <div class="m">dash</div>, <div class="m">dot</div>.
- <div class="m">width</div> - ширина пера (от 1 до 10 пикселей).
- <div class="m">color</div> - цвет пера (см. <a class="cmd" href="#color">color</a>).
</ul><div class="cmd">brush createBrush(table params)</div> - создание кисти.
Параметры для создания кисти <div class="m">brush</div>:
<ul>- <div class="m">style</div> - стиль кисти. Возможные варианты: <div class="m">solid</div> (по умолчанию), <div class="m">vertical</div>, <div class="m">horizontal</div>, 
<div class="m">cross</div>, <div class="m">diagonal</div>, <div class="m">diagcross</div>.
- <div class="m">color</div> - цвет кисти (см. <a class="cmd" href="#color">color</a>).
</ul>
<div class="cmd">font createFont(table params)</div> - создание шрифта.
Параметры для создания шрифта <div class="m">font</div>:
<ul>- <div class="m">name</div> - имя шрифта. Например: arial, tahoma, fixedsys.
- <div class="m">height</div> - высота шрифта.
- <div class="m">bold</div> - толщина шрифта.
- <div class="m">italic</div> - признак курсива шрифта.
</ul>
Пример:<div class="ee">local font = createFont{name='tahoma', height=9}</div>

<div class="cmd">void select(pen|brush|font)</div> - установка пера, кисти или шрифта, как текущих для рисования.
<div class="cmd">void rect(table rect)</div> - рисование прямоугольника текущем пером.

Возможные варианты определения <div class="m">rect</div> (прямоугольника):
<ul>- { left, top, right, bottom } - через определение границ прямоугольника.
- { left, top, width, height } - через определение левой и верхней границ + ширина и высота.
- { x, y, width, height } - через определение левой верхней точки + ширина и высота (аналог предыдущего варианта).
- { 10, 20, 30, 40 } - через простой набор чисел. В таком случае используется 
вариант left, top, right, bottom соответственно.
</ul>Примеры:<div class="ee">local r = { left=10, right=20, top=10, bottom=20 }
render:solidRect{ x=10, y=20, width=10, height=10 }
local r2 = { 10, 20, 40, 50 }
render:rect(r2)
</div>
<div class="cmd">void solidRect(table rect)</div> - рисование закрашенного прямоугольника. Используется текущая кисть. Формат rect см. выше
<div class="cmd">void print(int x, int y, string text)</div> - печать текста по заданным координатам. Используется текущий шрифт и цвет <div class="cmd">textColor</div>.
<div class="cmd">void update()</div> - сообщить окну, что нужно перерисовать содержимое.
<div class="cmd">int fontHeight()</div> - возвращает высоту текущего шрифта в пикселях.
<div class="cmd">int textWidth(string text)</div> - возвращает ширину текста в пикселях (для расчета используется текущий шрифт).
</pre>
<hr>
<a name="props"></a>
<h4>props</h4>
Данный набор функции предназначен для получения текущих настроек клиента. С помощью данных методов настройки изменить нельзя. В С++ есть 
аналогичный набор методов: <a href="#cppprops" class="cmd">luaT_Props</a>.
<pre>
<div class="cmd">uint paletteColor(int index)</div> - цвет из палитры клиента по индексу. Допустимые значения индекса от 0 до 255.
Пример получения цвета текста с индексом 7 (цвет по умолчанию):
<div class="ee">local color = props.paletteColor(7)</div>
<div class="cmd">uint backgroundColor()</div> - цвет фона всех окон клиента.
<div class="cmd">font currentFont()</div> - текущий шрифт в клиенте.
<div class="cmd">string cmdPrefix()</div> - символ-префикс для системной команды. Не используйте в плагинах 'жестко' заданный символ команды (он может поменяться).
<div class="cmd">string cmdSeparator()</div> - символ-разделитель для команд. Не используйте 'жестко' заданный символ сепаратора в плагинах (он может поменяться).
<div class="cmd">string serverHost()</div> - возвращает адрес сервера, к которому подключен клиент или nil, если нет подключения.
<div class="cmd">string serverPort()</div> - возвращает порт сервера или nil, если нет подключения.
<div class="cmd">bool connected()</div> - возвращает признак наличия подключения.
<div class="cmd">bool activated()</div> -  признак, что окно клиента активно и игрок работает с ним.
</pre>
<hr>
<a name="luaactobj"></a>
<h4>Манипуляции с объектам клиента.</h4>
Данные функции(объекты) предназначены для манипуляции с триггерами, макросами и др. элементами клиента. Данное описание 
корелируется с классом <a href="#cppactobj" class="cmd">luaT_ActiveObjects</a>, так как они предназначены для одно и того же.<br><br>
Доступ из скриптов Lua идет через использование глобальных объектов:
<ul>
<li><div class="m">aliases</div> - макросы</li>
<li><div class="m">actions</div> - триггеры</li>
<li><div class="m">subs</div> - замены</li>
<li><div class="m">antisubs</div> - антизамены</li>
<li><div class="m">highlights</div> - подсветки</li>
<li><div class="m">hotkeys</div> - горячие клавиши</li>
<li><div class="m">gags</div> - фильтры</li>
<li><div class="m">vars</div> - переменные</li>
<li><div class="m">groups</div> - группы</li>
<li><div class="m">timers</div> - таймеры</li>
<li><div class="m">tabs</div> - подстановки</li>
</ul>
<div class="m">Внимание!</div> Все индексы начинаются с 1, а не с 0, как это принято в языке Lua.
<br><br>Данные объекты полностю идентичны, и это список их функций:
<pre>
<div class="cmd">int  size()</div> - возвращает число элементов.
<div class="cmd">bool select(int index)</div> - выбор элемента для работы.
<div class="cmd">bool set(string type, string value)</div> - задает значение атрибута для текущего элемента.
Возможные варианты атрибута: 'key', 'value', 'group'.
<div class="cmd">string get(string type)</div> - возвращает значения атрибута. Если атрибут неверный, возвращается nul.
<div class="cmd">bool add(string key[ ,string value, string group])</div> - добавляет новый элемент. Если не указана группа, то 
элемент добавляется в первую группу. Если элемент существует, то происходит ошибка и добавление не происходит.
<div class="cmd">bool replace(string key[ ,string value, string group])</div> - заменяет текущий элемент. Если элемент не 
существует, то он добавляется.
<div class="cmd">bool delete()</div> - удаляет текущий элемент.
<div class="cmd">int  getIndex()</div> - возвращает индекс-приоритет текущего элемента.
<div class="cmd">bool setIndex(int index)</div> - установка текущего приоритета у текущего элемента.
</pre>
Пример (добавить макрос есть):
<pre><div class="ee">aliases.add("есть", "съесть хлеб", "default")
</div></pre>
<hr>
<a name="viewdata"></a>
<h4>viewdata</h4>
Объект, который не является глобальным, используется при работе с методами <a href="#before" class="cmd">before</a> и 
<a href="#after" class="cmd">after</a>. Он предназначен для манипуляции со строками, которые плагин получает от клиента 
через эти методы. В C++ есть подобный интерфейс <a href="#cppviewdata" class="cmd">luaT_ViewData</a>.
<br><div class="m">Внимание!</div> Все индексы начинаются с 1, а не с 0, как это принято в языке Lua.
<pre>
<div class="cmd">int  size()</div> - возвращает количество строк в коллекции.
<div class="cmd">bool select(int index)</div> - выбор текущей строки для работы.
<div class="cmd">int  getIndex()</div> - индекс текущей строки.
<div class="cmd">bool isFirst()</div> - возвращает признак, что первая строка - это продолжение последней строки прошлой коллекции.
<div class="cmd">bool isLast()</div> - последняя строка является завершенной, ее продолжения в следующей коллекции не будет.
<div class="cmd">bool isGameCmd()</div> - в строке присутствует игровая команда.
<div class="cmd">bool isSystem()</div> - это строка с логом клиента.
<div class="cmd">bool isPrompt()</div> - это prompt-строка.
<div class="cmd">string getPrompt()</div> - содежимое prompt-строки (без игровых команд).
<div class="cmd">string getText()</div> - полный текст строки (без учета расцветок отдельных частей).
<div class="cmd">int  getTextLen()</div> - длина полного текста строки.
<div class="cmd">string getHash()</div> - хэш строки. Используется для быстрого сравнения строк.
<div class="cmd">int  blocks()</div> - количество блоков в текущей строке.
<div class="cmd">uint get(int index, string attr)</div> - получает значение атрибута блока. Возможные варианты атрибута: 
<div class="m">textcolor</div>,<div class="m">bkgcolor</div>,<div class="m">underline</div>,<div class="m">italic</div>,<div class="m">blink</div>,<div class="m">reverse</div>,<div class="m">exttextcolor</div>,<div class="m">extbkgcolor</div>.
<div class="cmd">bool set(int index, string attr, uint value)</div> - задает значение атрибута блока. Возможные варианты атрибута см. в <div class="m">get</div>.
<div class="cmd">string getBlockText(int index)</div> - текст блока по заданному индексу.
<div class="cmd">bool setBlockText(int index, string text)</div> - задает новый текст блоку по индексу.
<div class="cmd">bool copyBlock(int block, int dst_string, int dst_block)</div> - копирует заданный блок текущей строки в другую строку.
<div class="cmd">bool deleteBlock(int index)</div> - удаляет блок.
<div class="cmd">bool deleteAllBlocks()</div> - удаляет все блоки, остается пустая строка.
<div class="cmd">bool createString([bool system, bool gamecmd])</div> - создает новую пустую строку. Строка добавляется между текущей строкой и следующей за ней. 
Необязательные параметры system, gamecmd - задают соответствующие флаги для новой строки.
<div class="cmd">bool deleteString()</div> - удаляет строку.
<div class="cmd">bool find(pcre regexp [,int from])</div> - ищет в массиве строк <div class="cmd">viewdata</div> строку, которая совпадает с регулярным выражением. 
Если поиск удался, то найденная строка становится текущей. Параметр from - необязательный, можно указать с какой 
строки начинать поиск. См. также <a href="#pcre" class="cmd">pcre</a>.
</pre>
<hr>
<a name="luamsdp"></a>
<h4>msdp</h4>
Объект предназначен для управления протоколом MSDP из плагина. Все данные по протоколу плагин будет получать через свой метод <a href="#msdp" class="cmd">msdp</a>. 
Сам стандарт протокола можно прочитать тут: <a href="http://tintin.sourceforge.net/msdp/" target="_blank">MSDP</a>.

<pre>
<div class="cmd">void list(string listname)</div> - запрос на получение списка команд/переменных нужной категории из числа поддерживаемых сервером. 
Чтобы получить список поддерживаемых категорий следует вызвать с параметром "LISTS" (см. станадрт протокола).
<div class="cmd">void send(string var|table vars)</div> - запрос на однократное получение текущих значений требуемых переменных. В качестве параметра - 
строка с именем переменной или таблица со списком переменных.
<div class="cmd">void reset(string var|table vars)</div> - запрос на сброс значений требуемых переменных в исходное состояние.
<div class="cmd">void report(string var|table vars)</div> - подписывание на оповещение сервером об изменении значений нужных переменных.
<div class="cmd">void unreport(string var|table vars)</div> - отказ об оповещения сервером об изменении значений переменных.
</pre>
См. также <a href="#cppmsdp" class="cmd">luaT_Msdp</a>.
<hr>
<a name="pcre"></a>
<h4>pcre</h4>
Это библиотека для работы с регулярными выражениями в стиле Perl. Для ее использования нужно знать данный диалект регулярных выражений. 
Она используется для сложного поиска и разбора текстовых строк. С ее помощью можно лекго искать нужные строки текста. 
На стороне С++ есть подобная возможность (см. <a href="#pcrecpp" class="cmd">Pcre в C++</a>). 
Регулярки в Lua создаются с помощью функции  <a href="#createpcre" class="cmd">createPcre</a>. 
<pre>
<div class="cmd">bool find(string text)</div> - обработка строки в регулярном выражении. Возвращает <div class="m">true</div>, если строка подходит к 
регулярному выражению или <div class="m">false</div>, если нет.
<div class="cmd">bool findall(string text)</div> - обработка строки в регулярном выражении. Ищутся все совпадения в строке, а не только первое.
Возвращает <div class="m">true</div>, если есть хоть одно совпадение, <div class="m">false</div>, если нет ни одного.
<div class="cmd">int size()</div> - возвращает количество совпадений в регулярном выражении. Для метода <div class="cmd">find</div> - возвращается 
количество найденных параметров в круглых скобках + 1 (совпадение по всему регулярному выражению).
Для метода <div class="cmd">findall</div> - количество всех найденных совпадений + 1 (для границ всех совпадений).

<div class="m">Пояснение:</div> 
Для каждого совпадения есть два числа - начало сопадения в строке поиска и окончание совпадения. 
Для метода <div class="cmd">find</div> - это границы для подстрок, попадающих в круглые скобки регулярного выражения. 
С индексом 1 - первые круглые скобки, 2 - вторые и т. д. Индекс 0 - границы совпадения всего регулярного выражения.
Для метода <div class="cmd">findall</div> - это границы для подстрок, которые подходят к регулярному выражению.  
С индексом 1 - первое совпадение, и т.д. Индекс 0 - границы всех совпадений (начало первого и окончание последнего совпадений).
<div class="cmd">int first(int index)</div> - возвращает левую границу (индекс символа в исходной строке), или -1 для неправильного индекса.
<div class="cmd">int last(int index)</div> - возвращает правую границу (индекс символа в исходной строке + 1), или -1.
<div class="cmd">string get(int index)</div> - возвращает подстроку по индексу (от левой границы до правой) или пустую строку, 
для неправильного индекса.
</pre>
<hr>
<a name="strings"></a>
<h2>Cтроки, ньюансы работы в Lua</h2>
В клиенте используется кодировка UTF8 для файлов на языке Lua, соответственно вся работа со строками в Lua идет в этой же кодировке. В текущей реализации Lua 5.2, которая 
используется в клиенте, нет нативной поддержки UTF8. Соответственно есть определенные ньюансы работы.<br><br>
- В клиенте не используется официальная библиотека <div class="m">string</div> для работы со строками, т.к. она не расчитана на работу с UTF8.<br>
- Операторы <div class="m">==</div>, <div class="m">~=</div>, <div class="m">&lt;</div>, <div class="m">&gt;</div> для сравнения строк можно использовать, 
так как сравнение идет побайтно, а UTF8 обладает свойством, что для нее прекрасно работают операторы сравнения обычных строк.<br>
- Оператор <div class="m">#</div> - длина строки будет работать неправильно, так как он будет возвращать длину строки в байтах, а не в символах.<br><br>
Примечание: К сожалению Lua не позволяет переопределить стандартные операторы для строки, поэтому для оператора <div class="m">#</div> не получилось сделать его 
правильную реализацию. Возможно решение этой проблемы будет найдено позднее.<br><br>

<h4>string</h4>
Для работы со строками, были написаны свои функции:<br>
<div class="m">Внимание!</div> Все индексы символов строки начинаются с 1, а не с 0, так как это принято в языке Lua.<br>
<pre>
<div class="cmd">int len()</div> - длина строки в символах. Данную функцию нужно использовать вместо оператора <div class="m">#</div>.
Пример:
<div class="ee">local s = "Мад отличная игра"
local l = s:len() -- l = 17
</div>
<div class="cmd">string substr(int len)</div> - возвращает подстроку (часть исходной строки) длиной в <div class="m">len</div> первых символов.
<div class="cmd">string substr(int from, int len)</div> - возвращает подстроку(часть исходной строки),
начиная с символа <div class="m">from</div> и длиной <div class="m">len</div> символов. <div class="m">from</div> начинается с 1 (первый символ).
Пример:
<div class="ee">local s = "Мад отличная игра"
local s1 = s:substr(3) -- s1 = "Мад"
local s2 = s:substr(5, 8) -- s2 = "отличная"
</div>
</pre>
<hr>
<a name="decoda"></a>
<h2>Decoda</h2>
<div class="m">Decoda</div> - является средой разработки для языка Lua. Она очень хорошо интегрируется и работает вместе с мад-клиентом. Она позволяет писать и отлаживать 
Lua-скрипты как отдельно, так и параллельно с Visual Studio. Decoda входит в SDK.<br><br>
Для работы с Decoda ее нужно настроить, для этого в окне <div class="m">Project\Settings</div> нужно выставить правильно настройки:
<ul>
<li><div class="m">Command</div> - это полный путь к exe мад клиента.</li> 
<li><div class="m">Command Arguments</div> - пустое поле.</li> 
<li><div class="m">Working Diectory</div> - полный путь к папке, где находится мад-клиент.</li> 
<li><div class="m">Symbols Directory</div> - пустое поле.</li>
</ul>
После этого можно загружать в Decoda lua-файлы и отлаживать их. Decoda будет запускать для этого мад-клиент. Главное, чтобы клиент загружал те же файлы, 
которые отслеживаются Decoda.<br>
Комбинации клавиш в Decoda подобны комбинации в Visual Studio, что достаточно удобно.<br><br>
Нудобством Decoda является то, что она не поддерживает файлы в кодировке UTF8. В этих строках пишутся иероглифы. Планируется исправить этот 
недочет и выпустить новую версию Decoda.
<hr>
<br><br><br>
</body></html>
